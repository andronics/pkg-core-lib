#!/usr/bin/env zsh
# schema-exec - Execute schema-driven actions
# Version: 1.0.0

echo "[DEBUG] schema-exec starting..." >&2

# Load dependencies
echo "[DEBUG] Loading _common..." >&2
source "$(which _common)" 2>/dev/null || {
    echo "Error: schema-exec requires _common library" >&2
    exit 1
}
echo "[DEBUG] _common loaded" >&2

echo "[DEBUG] Loading _log..." >&2
source "$(which _log)" 2>/dev/null || {
    # Fallback logging
    log-info() { echo "[INFO] $*"; }
    log-error() { echo "[ERROR] $*" >&2; }
    log-warn() { echo "[WARN] $*" >&2; }
    log-success() { echo "[SUCCESS] $*"; }
    log-debug() { [[ "${DEBUG:-false}" == "true" ]] && echo "[DEBUG] $*" >&2 || true; }
}
echo "[DEBUG] _log loaded" >&2

source "$(which _actions)" 2>/dev/null || {
    log-error "schema-exec requires _actions library"
    exit 1
}

source "$(which _plugins)" 2>/dev/null || {
    log-error "schema-exec requires _plugins library"
    exit 1
}

# Disable automatic ERR trap (we handle errors explicitly)
declare -g LIFECYCLE_TRAP_ERRORS=false

source "$(which _lifecycle)" 2>/dev/null || {
    log-error "schema-exec requires _lifecycle library"
    exit 1
}

###########################################
# Configuration
###########################################

declare -g SCHEMA_EXEC_VERSION="1.0.0"
declare -g SCHEMA_EXEC_CHECKPOINT=""
declare -g SCHEMA_EXEC_SAVE_CHECKPOINT=""
declare -g SCHEMA_EXEC_RESUME=false
declare -g SCHEMA_EXEC_DRY_RUN=false
declare -g SCHEMA_EXEC_VERBOSE=false

###########################################
# Functions
###########################################

# Show version
show_version() {
    echo "schema-exec v${SCHEMA_EXEC_VERSION}"
    echo "Schema-driven action execution engine"
}

# Show help
show_help() {
    cat <<'EOF'
schema-exec - Execute schema-driven actions

USAGE:
    schema-exec [OPTIONS] <schema-file>

OPTIONS:
    -h, --help              Show this help message
    -v, --version           Show version information
    -d, --dry-run           Dry run mode (don't execute, just show plan)
    -V, --verbose           Verbose output (enable debug logging)

    CHECKPOINT/RESUME:
    --checkpoint NAME       Load checkpoint and resume from there
    --save-checkpoint NAME  Save checkpoint after execution
    --resume                Resume from last checkpoint (if exists)

    PLUGIN MANAGEMENT:
    --list-plugins          List available plugins
    --plugin-info NAME      Show plugin information
    --validate-plugins      Validate all discovered plugins

SCHEMA FILE:
    Path to YAML or JSON schema file following the action/v1 format.
    See documentation for schema structure and examples.

EXAMPLES:
    # Execute a schema
    schema-exec deploy.yaml

    # Dry run to see execution plan
    schema-exec --dry-run deploy.yaml

    # Execute with checkpoint save
    schema-exec --save-checkpoint after-deploy deploy.yaml

    # Resume from checkpoint
    schema-exec --checkpoint after-deploy deploy.yaml

    # Verbose execution
    schema-exec --verbose deploy.yaml

ENVIRONMENT:
    DEBUG=true              Enable debug logging (same as --verbose)
    LIFECYCLE_DRY_RUN=true  Enable dry run mode (same as --dry-run)

EXIT CODES:
    0   Success
    1   General error
    2   Invalid arguments
    3   Schema validation failed
    4   Plugin initialization failed
    5   Action execution failed

For more information: https://github.com/andronics/dotfiles
EOF
}

# List plugins
list_plugins() {
    log-info "Discovering plugins..."
    plugin-discover || {
        log-error "Plugin discovery failed"
        return 1
    }

    local plugins=($(plugin-list))
    if [[ ${#plugins[@]} -eq 0 ]]; then
        echo "No plugins found"
        return 0
    fi

    echo "Available Plugins:"
    echo ""

    for name in "${plugins[@]}"; do
        local version=$(plugin-get "$name" "version" "unknown")
        local description=$(plugin-get "$name" "description" "No description")
        local state=$(plugin-get-state "$name")

        echo "  $name (v$version) [$state]"
        echo "    $description"
        echo ""
    done

    echo "Total: ${#plugins[@]} plugins"
}

# Show plugin info
show_plugin_info() {
    local plugin_name="$1"

    log-info "Discovering plugins..."
    plugin-discover || {
        log-error "Plugin discovery failed"
        return 1
    }

    plugin-info "$plugin_name"
}

# Validate all plugins
validate_plugins() {
    log-info "Discovering plugins..."
    plugin-discover || {
        log-error "Plugin discovery failed"
        return 1
    }

    local plugins=($(plugin-list))
    local failed=0

    echo "Validating ${#plugins[@]} plugins..."
    echo ""

    for name in "${plugins[@]}"; do
        echo -n "  $name ... "
        if plugin-validate "$name" >/dev/null 2>&1; then
            echo "✓ VALID"
        else
            echo "✗ INVALID"
            plugin-validate "$name"
            ((failed++))
        fi
    done

    echo ""
    if [[ $failed -eq 0 ]]; then
        log-success "All plugins validated successfully"
        return 0
    else
        log-error "$failed plugin(s) failed validation"
        return 1
    fi
}

# Execute schema
execute_schema() {
    local schema_file="$1"
    echo "[DEBUG execute_schema] Called with: $schema_file" >&2

    # Validate schema file exists
    if [[ ! -f "$schema_file" ]]; then
        log-error "Schema file not found: $schema_file"
        return 2
    fi

    # Validate schema structure
    log-info "Validating schema: $schema_file"
    if ! schema-validate "$schema_file"; then
        log-error "Schema validation failed"
        return 3
    fi

    # Bootstrap plugin system
    log-info "Initializing plugin system..."
    if ! plugin-bootstrap; then
        log-error "Plugin initialization failed"
        return 4
    fi

    # Handle checkpoint resume
    if [[ -n "$SCHEMA_EXEC_CHECKPOINT" ]]; then
        log-info "Loading checkpoint: $SCHEMA_EXEC_CHECKPOINT"
        lifecycle-checkpoint-load "$SCHEMA_EXEC_CHECKPOINT" || {
            log-warn "Failed to load checkpoint, starting fresh"
        }
    elif [[ "$SCHEMA_EXEC_RESUME" == "true" ]]; then
        local last_checkpoint=$(lifecycle-checkpoint-list | head -1 | awk '{print $1}')
        if [[ -n "$last_checkpoint" ]]; then
            log-info "Resuming from last checkpoint: $last_checkpoint"
            lifecycle-checkpoint-load "$last_checkpoint" || {
                log-warn "Failed to load checkpoint, starting fresh"
            }
        fi
    fi

    # Execute schema
    log-info "Executing schema: $schema_file"
    if action-execute-schema "$schema_file"; then
        log-success "Schema execution completed successfully"

        # Save checkpoint if requested
        if [[ -n "$SCHEMA_EXEC_SAVE_CHECKPOINT" ]]; then
            log-info "Saving checkpoint: $SCHEMA_EXEC_SAVE_CHECKPOINT"
            lifecycle-checkpoint-save "$SCHEMA_EXEC_SAVE_CHECKPOINT" || {
                log-warn "Failed to save checkpoint"
            }
        fi

        return 0
    else
        log-error "Schema execution failed"

        # Auto-save checkpoint on failure for resume
        if [[ -n "$SCHEMA_EXEC_SAVE_CHECKPOINT" ]]; then
            log-info "Saving failure checkpoint: ${SCHEMA_EXEC_SAVE_CHECKPOINT}_failed"
            lifecycle-checkpoint-save "${SCHEMA_EXEC_SAVE_CHECKPOINT}_failed" || {
                log-warn "Failed to save failure checkpoint"
            }
        fi

        return 5
    fi
}

###########################################
# Main
###########################################

main() {
    echo "[DEBUG main] Starting main function with args: $@" >&2
    local schema_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -d|--dry-run)
                SCHEMA_EXEC_DRY_RUN=true
                LIFECYCLE_DRY_RUN=true
                export LIFECYCLE_DRY_RUN
                shift
                ;;
            -V|--verbose)
                SCHEMA_EXEC_VERBOSE=true
                LIFECYCLE_DEBUG=true
                DEBUG=true
                export LIFECYCLE_DEBUG DEBUG
                shift
                ;;
            --checkpoint)
                SCHEMA_EXEC_CHECKPOINT="$2"
                shift 2
                ;;
            --save-checkpoint)
                SCHEMA_EXEC_SAVE_CHECKPOINT="$2"
                shift 2
                ;;
            --resume)
                SCHEMA_EXEC_RESUME=true
                shift
                ;;
            --list-plugins)
                list_plugins
                exit $?
                ;;
            --plugin-info)
                show_plugin_info "$2"
                exit $?
                ;;
            --validate-plugins)
                validate_plugins
                exit $?
                ;;
            -*)
                log-error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 2
                ;;
            *)
                if [[ -z "$schema_file" ]]; then
                    schema_file="$1"
                    shift
                else
                    log-error "Unexpected argument: $1"
                    exit 2
                fi
                ;;
        esac
    done

    # Require schema file for execution
    if [[ -z "$schema_file" ]]; then
        log-error "Schema file required"
        echo "Use --help for usage information"
        exit 2
    fi

    echo "[DEBUG main] Schema file: $schema_file" >&2
    # NOTE: lifecycle-trap-install hangs on some systems due to trap installation failures
    # We don't actually need signal handlers for schema execution
    # lifecycle-trap-install
    echo "[DEBUG main] Skipping lifecycle handlers" >&2

    # Execute
    echo "[DEBUG main] Calling execute_schema..." >&2
    execute_schema "$schema_file"
    exit $?
}

# Run main
main "$@"
