#!/usr/bin/env zsh

# _validation - Generic validation framework
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Purpose:
#   Provides a comprehensive validation framework for type checking,
#   constraint validation, and schema-based validation. Extracted from
#   _config and _args to serve as a foundation for _schema and _actions.
#
# Usage:
#   source "$(which _validation)"
#   validate-type "42" "integer" || echo "Invalid"
#   validate-constraint "5" "min:1,max:10" || echo "Out of range"
#   validate-required '{"name":"test"}' "name,version" || echo "Missing fields"
#
# Features:
#   - Type validation (string, int, bool, float, enum, path, etc.)
#   - Constraint validation (min/max, regex, range, length, etc.)
#   - Required field validation
#   - Custom validator registration
#   - Detailed error messages
#   - Chainable validation
#
# Dependencies:
#   - _common (required)

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${VALIDATION_LOADED:-}" ]] && return 0

# ------------------------------
# Version
# ------------------------------

declare -gr VALIDATION_VERSION="1.0.0"
declare -g VALIDATION_LOADED=1

# ------------------------------
# Load Dependencies
# ------------------------------

# Load _common (required) from same directory
_VALIDATION_DIR="${${(%):-%x}:A:h}"
if ! source "$_VALIDATION_DIR/_common" 2>/dev/null; then
    # Fallback: try multiple locations
    local _found=false
    for _path in \
        "$HOME/.local/bin/lib/_common" \
        "$HOME/.dotfiles/lib/.local/bin/lib/_common"; do
        if [[ -f "$_path" ]] && source "$_path" 2>/dev/null; then
            _found=true
            break
        fi
    done
    if [[ "$_found" != "true" ]]; then
        echo "[ERROR] _validation requires _common extension" >&2
        return 1
    fi
    unset _found _path
fi
unset _VALIDATION_DIR

# ------------------------------
# Configuration Variables
# ------------------------------

declare -g VALIDATION_VERBOSE="${VALIDATION_VERBOSE:-false}"
declare -g VALIDATION_DEBUG="${VALIDATION_DEBUG:-false}"
declare -g VALIDATION_STRICT="${VALIDATION_STRICT:-true}"

# ------------------------------
# Internal State
# ------------------------------

# Custom validators registry
declare -g -A _VALIDATION_CUSTOM=()

# Last validation error
declare -g VALIDATION_LAST_ERROR=""

# Statistics
declare -g _VALIDATION_TOTAL_CHECKS=0
declare -g _VALIDATION_TOTAL_FAILURES=0

# ------------------------------
# Color Constants
# ------------------------------

declare -gr _VALIDATION_COLOR_ERROR="$COLOR_RED"
declare -gr _VALIDATION_COLOR_WARNING="$COLOR_YELLOW"
declare -gr _VALIDATION_COLOR_DEBUG="$COLOR_BLUE"

# ------------------------------
# Internal Logging Functions
# ------------------------------

_validation-log-debug() {
    [[ "$VALIDATION_DEBUG" == "true" ]] || return 0
    echo -e "${_VALIDATION_COLOR_DEBUG}[DEBUG] validation: $*${COLOR_RESET}" >&2
}

_validation-log-verbose() {
    [[ "$VALIDATION_VERBOSE" == "true" ]] || return 0
    echo "[INFO] validation: $*" >&2
}

_validation-log-error() {
    echo -e "${_VALIDATION_COLOR_ERROR}[ERROR] validation: $*${COLOR_RESET}" >&2
    VALIDATION_LAST_ERROR="$*"
    ((_VALIDATION_TOTAL_FAILURES++))
}

_validation-log-warning() {
    echo -e "${_VALIDATION_COLOR_WARNING}[WARNING] validation: $*${COLOR_RESET}" >&2
}

# ------------------------------
# Type Validators
# ------------------------------

# String validation (non-empty)
validate-type-string() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ -n "$value" ]]; then
        return 0
    else
        _validation-log-error "String value is empty"
        return 1
    fi
}

# Integer validation
validate-type-integer() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^-?[0-9]+$ ]]; then
        return 0
    else
        _validation-log-error "Value is not an integer: '$value'"
        return 1
    fi
}

# Positive integer validation
validate-type-positive-integer() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[0-9]+$ ]] && [[ "$value" -gt 0 ]]; then
        return 0
    else
        _validation-log-error "Value is not a positive integer: '$value'"
        return 1
    fi
}

# Non-negative integer validation
validate-type-non-negative-integer() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[0-9]+$ ]]; then
        return 0
    else
        _validation-log-error "Value is not a non-negative integer: '$value'"
        return 1
    fi
}

# Boolean validation
validate-type-boolean() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^(true|false|0|1|yes|no|on|off)$ ]]; then
        return 0
    else
        _validation-log-error "Value is not a boolean: '$value' (use true/false/yes/no/1/0/on/off)"
        return 1
    fi
}

# Float/number validation
validate-type-float() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^-?[0-9]+\.?[0-9]*$ ]] || [[ "$value" =~ ^-?\.[0-9]+$ ]]; then
        return 0
    else
        _validation-log-error "Value is not a number: '$value'"
        return 1
    fi
}

# Path validation (exists or is valid path syntax)
validate-type-path() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    # Valid if exists or is absolute/relative path
    if [[ -e "$value" ]] || [[ "$value" == /* ]] || [[ "$value" == ~/* ]] || \
       [[ "$value" == ./* ]] || [[ "$value" == ../* ]]; then
        return 0
    else
        _validation-log-error "Invalid path: '$value'"
        return 1
    fi
}

# File validation (must exist and be a file)
validate-type-file() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ -f "$value" ]]; then
        return 0
    else
        _validation-log-error "File not found or not a regular file: '$value'"
        return 1
    fi
}

# Directory validation (must exist and be a directory)
validate-type-directory() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ -d "$value" ]]; then
        return 0
    else
        _validation-log-error "Directory not found: '$value'"
        return 1
    fi
}

# URL validation (basic http/https check)
validate-type-url() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^https?:// ]]; then
        return 0
    else
        _validation-log-error "Invalid URL (must start with http:// or https://): '$value'"
        return 1
    fi
}

# Email validation (basic regex)
validate-type-email() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
        return 0
    else
        _validation-log-error "Invalid email address: '$value'"
        return 1
    fi
}

# JSON validation (basic syntax check, optionally use jq)
validate-type-json() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if common-command-exists "jq"; then
        if echo "$value" | jq empty 2>/dev/null; then
            return 0
        else
            _validation-log-error "Invalid JSON: '$value'"
            return 1
        fi
    else
        # Basic JSON validation without jq
        if [[ "$value" =~ ^\{.*\}$ ]] || [[ "$value" =~ ^\[.*\]$ ]]; then
            return 0
        else
            _validation-log-error "Invalid JSON syntax: '$value'"
            return 1
        fi
    fi
}

# IP address validation (IPv4)
validate-type-ip() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        # Check each octet is 0-255
        local -a octets=("${(@s:.:)value}")
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]]; then
                _validation-log-error "Invalid IP address (octet out of range): '$value'"
                return 1
            fi
        done
        return 0
    else
        _validation-log-error "Invalid IP address format: '$value'"
        return 1
    fi
}

# Port number validation (1-65535)
validate-type-port() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[0-9]+$ ]] && [[ "$value" -ge 1 ]] && [[ "$value" -le 65535 ]]; then
        return 0
    else
        _validation-log-error "Invalid port number (must be 1-65535): '$value'"
        return 1
    fi
}

# Enum validation (value must be in allowed list)
validate-type-enum() {
    local value="$1"
    local enum_values="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    common-validate-required "$enum_values" "enum_values" || return 2

    # Split enum_values by pipe character
    local -a allowed=("${(@s:|:)enum_values}")

    for val in "${allowed[@]}"; do
        if [[ "$value" == "$val" ]]; then
            return 0
        fi
    done

    _validation-log-error "Value not in enum: '$value' (allowed: ${enum_values//|/, })"
    return 1
}

# UUID validation
validate-type-uuid() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$ ]]; then
        return 0
    else
        _validation-log-error "Invalid UUID format: '$value'"
        return 1
    fi
}

# Semver validation
validate-type-semver() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9.+-]+)?$ ]]; then
        return 0
    else
        _validation-log-error "Invalid semantic version: '$value' (expected: X.Y.Z or X.Y.Z-prerelease)"
        return 1
    fi
}

# Hostname validation
validate-type-hostname() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ ^[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$ ]]; then
        return 0
    else
        _validation-log-error "Invalid hostname: '$value'"
        return 1
    fi
}

# Array validation (accepts any value, serves as type marker)
validate-type-array() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))
    return 0
}

# Object validation (accepts any value, serves as type marker)
validate-type-object() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))
    return 0
}

# Any validation (always passes)
validate-type-any() {
    local value="$1"
    ((_VALIDATION_TOTAL_CHECKS++))
    return 0
}

# ------------------------------
# Generic Type Validation
# ------------------------------

# Main type validation dispatcher
# Usage: validate-type <value> <type> [type_param]
validate-type() {
    local value="$1"
    local type="$2"
    local type_param="${3:-}"

    common-validate-required "$type" "type" || return 2

    _validation-log-debug "Validating type: '$type' for value: '$value'"

    case "$type" in
        string)
            validate-type-string "$value"
            ;;
        int|integer)
            validate-type-integer "$value"
            ;;
        positive-int|positive-integer)
            validate-type-positive-integer "$value"
            ;;
        non-negative-int|non-negative-integer)
            validate-type-non-negative-integer "$value"
            ;;
        bool|boolean)
            validate-type-boolean "$value"
            ;;
        float|number|numeric)
            validate-type-float "$value"
            ;;
        path)
            validate-type-path "$value"
            ;;
        file)
            validate-type-file "$value"
            ;;
        directory|dir)
            validate-type-directory "$value"
            ;;
        url)
            validate-type-url "$value"
            ;;
        email)
            validate-type-email "$value"
            ;;
        json)
            validate-type-json "$value"
            ;;
        ip|ipv4)
            validate-type-ip "$value"
            ;;
        port)
            validate-type-port "$value"
            ;;
        enum)
            validate-type-enum "$value" "$type_param"
            ;;
        uuid)
            validate-type-uuid "$value"
            ;;
        semver|version)
            validate-type-semver "$value"
            ;;
        hostname)
            validate-type-hostname "$value"
            ;;
        array)
            validate-type-array "$value"
            ;;
        object)
            validate-type-object "$value"
            ;;
        any)
            validate-type-any "$value"
            ;;
        *)
            # Check for custom validator
            if [[ -n "${_VALIDATION_CUSTOM[$type]}" ]]; then
                local validator="${_VALIDATION_CUSTOM[$type]}"
                if common-function-exists "$validator"; then
                    "$validator" "$value" "$type_param"
                    return $?
                else
                    _validation-log-error "Custom validator function not found: $validator"
                    return 1
                fi
            else
                _validation-log-warning "Unknown type: $type, treating as 'any'"
                return 0
            fi
            ;;
    esac
}

# ------------------------------
# Constraint Validators
# ------------------------------

# Min value constraint
validate-constraint-min() {
    local value="$1"
    local min="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" -ge "$min" ]]; then
        return 0
    else
        _validation-log-error "Value $value is less than minimum $min"
        return 1
    fi
}

# Max value constraint
validate-constraint-max() {
    local value="$1"
    local max="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" -le "$max" ]]; then
        return 0
    else
        _validation-log-error "Value $value is greater than maximum $max"
        return 1
    fi
}

# Range constraint (min and max)
validate-constraint-range() {
    local value="$1"
    local min="$2"
    local max="$3"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" -ge "$min" ]] && [[ "$value" -le "$max" ]]; then
        return 0
    else
        _validation-log-error "Value $value is outside range [$min, $max]"
        return 1
    fi
}

# Min length constraint
validate-constraint-minlength() {
    local value="$1"
    local min="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ ${#value} -ge "$min" ]]; then
        return 0
    else
        _validation-log-error "Value length ${#value} is less than minimum length $min"
        return 1
    fi
}

# Max length constraint
validate-constraint-maxlength() {
    local value="$1"
    local max="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ ${#value} -le "$max" ]]; then
        return 0
    else
        _validation-log-error "Value length ${#value} is greater than maximum length $max"
        return 1
    fi
}

# Exact length constraint
validate-constraint-length() {
    local value="$1"
    local length="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ ${#value} -eq "$length" ]]; then
        return 0
    else
        _validation-log-error "Value length ${#value} is not equal to required length $length"
        return 1
    fi
}

# Regex pattern constraint
validate-constraint-pattern() {
    local value="$1"
    local pattern="$2"
    ((_VALIDATION_TOTAL_CHECKS++))

    if [[ "$value" =~ $pattern ]]; then
        return 0
    else
        _validation-log-error "Value '$value' does not match pattern '$pattern'"
        return 1
    fi
}

# Generic constraint validation dispatcher
# Usage: validate-constraint <value> <constraint_string>
# Constraint string format: "constraint1:param1,constraint2:param2"
# Examples: "min:1,max:100", "minlength:3,maxlength:50", "pattern:^[a-z]+$"
validate-constraint() {
    local value="$1"
    local constraint_string="$2"

    common-validate-required "$constraint_string" "constraint_string" || return 2

    # Split constraint string by comma
    local -a constraints=("${(@s:,:)constraint_string}")

    for constraint in "${constraints[@]}"; do
        # Skip empty constraints
        [[ -z "$constraint" ]] && continue

        # Split constraint into name and parameter
        local constraint_name="${constraint%%:*}"
        local constraint_param="${constraint#*:}"

        # If no colon, constraint_param will be same as constraint_name
        [[ "$constraint_param" == "$constraint_name" ]] && constraint_param=""

        _validation-log-debug "Checking constraint: $constraint_name=$constraint_param"

        case "$constraint_name" in
            min)
                validate-constraint-min "$value" "$constraint_param" || return 1
                ;;
            max)
                validate-constraint-max "$value" "$constraint_param" || return 1
                ;;
            range)
                # Range expects two params: min and max separated by hyphen
                local min="${constraint_param%%-*}"
                local max="${constraint_param##*-}"
                validate-constraint-range "$value" "$min" "$max" || return 1
                ;;
            minlength|min_length)
                validate-constraint-minlength "$value" "$constraint_param" || return 1
                ;;
            maxlength|max_length)
                validate-constraint-maxlength "$value" "$constraint_param" || return 1
                ;;
            length)
                validate-constraint-length "$value" "$constraint_param" || return 1
                ;;
            pattern|regex)
                validate-constraint-pattern "$value" "$constraint_param" || return 1
                ;;
            *)
                _validation-log-warning "Unknown constraint: $constraint_name"
                if [[ "$VALIDATION_STRICT" == "true" ]]; then
                    return 1
                fi
                ;;
        esac
    done

    return 0
}

# ------------------------------
# Required Field Validation
# ------------------------------

# Validate required fields in data (simple flat key check)
# Usage: validate-required <data> <required_fields>
# where required_fields is comma-separated list: "name,version,type"
validate-required() {
    local data="$1"
    local required_fields="$2"

    common-validate-required "$data" "data" || return 2
    common-validate-required "$required_fields" "required_fields" || return 2

    local -a fields=("${(@s:,:)required_fields}")
    local missing_fields=()

    for field in "${fields[@]}"; do
        # Skip empty fields
        [[ -z "$field" ]] && continue

        # Check if field exists in data (basic string search)
        if ! echo "$data" | grep -q "\"$field\""; then
            missing_fields+=("$field")
        fi
    done

    if [[ ${#missing_fields[@]} -gt 0 ]]; then
        _validation-log-error "Missing required fields: ${(j:, :)missing_fields}"
        return 1
    fi

    return 0
}

# ------------------------------
# Custom Validator Registration
# ------------------------------

# Register a custom validator function
# Usage: validate-register <type_name> <validator_function>
validate-register() {
    local type_name="$1"
    local validator_func="$2"

    common-validate-required "$type_name" "type_name" || return 2
    common-validate-required "$validator_func" "validator_func" || return 2

    if ! common-function-exists "$validator_func"; then
        _validation-log-error "Validator function does not exist: $validator_func"
        return 1
    fi

    _VALIDATION_CUSTOM[$type_name]="$validator_func"
    _validation-log-verbose "Registered custom validator: $type_name -> $validator_func"

    return 0
}

# Unregister a custom validator
# Usage: validate-unregister <type_name>
validate-unregister() {
    local type_name="$1"

    common-validate-required "$type_name" "type_name" || return 2

    if [[ -n "${_VALIDATION_CUSTOM[$type_name]}" ]]; then
        unset "_VALIDATION_CUSTOM[$type_name]"
        _validation-log-verbose "Unregistered custom validator: $type_name"
        return 0
    else
        _validation-log-warning "Custom validator not found: $type_name"
        return 1
    fi
}

# List registered custom validators
# Usage: validate-list-custom
validate-list-custom() {
    if [[ ${#_VALIDATION_CUSTOM[@]} -eq 0 ]]; then
        echo "No custom validators registered"
        return 0
    fi

    echo "Registered Custom Validators:"
    for type_name in "${(@k)_VALIDATION_CUSTOM}"; do
        echo "  $type_name => ${_VALIDATION_CUSTOM[$type_name]}"
    done
}

# ------------------------------
# Utility Functions
# ------------------------------

# Get last validation error
# Usage: validate-get-error
validate-get-error() {
    echo "$VALIDATION_LAST_ERROR"
}

# Clear last validation error
# Usage: validate-clear-error
validate-clear-error() {
    VALIDATION_LAST_ERROR=""
}

# Normalize boolean value to true/false
# Usage: validate-normalize-bool <value>
validate-normalize-bool() {
    local value="$1"

    case "${value:l}" in
        true|1|yes|on)
            echo "true"
            ;;
        false|0|no|off)
            echo "false"
            ;;
        *)
            echo "$value"
            ;;
    esac
}

# ------------------------------
# Statistics
# ------------------------------

validate-stats() {
    echo "Validation Statistics:"
    echo "  Version: $VALIDATION_VERSION"
    echo "  Total Checks: $_VALIDATION_TOTAL_CHECKS"
    echo "  Total Failures: $_VALIDATION_TOTAL_FAILURES"
    echo "  Success Rate: $(( 100 * (_VALIDATION_TOTAL_CHECKS - _VALIDATION_TOTAL_FAILURES) / (_VALIDATION_TOTAL_CHECKS + 1) ))%"
    echo "  Custom Validators: ${#_VALIDATION_CUSTOM[@]}"
    echo "  Strict Mode: $VALIDATION_STRICT"
}

# ------------------------------
# Help
# ------------------------------

validate-help() {
    cat <<'EOF'
validation - Generic validation framework
Version: 1.0.0

Usage:
  source "$(which _validation)"
  validate-type "42" "integer" || echo "Invalid"
  validate-constraint "5" "min:1,max:10" || echo "Out of range"

Type Validation:
  validate-type <value> <type> [type_param]

Supported Types:
  string                  - Non-empty string
  integer, int            - Integer number
  positive-integer        - Positive integer (> 0)
  non-negative-integer    - Non-negative integer (>= 0)
  boolean, bool           - Boolean (true/false/yes/no/1/0/on/off)
  float, number           - Floating point number
  path                    - Valid file path
  file                    - Existing file
  directory, dir          - Existing directory
  url                     - HTTP/HTTPS URL
  email                   - Email address
  json                    - Valid JSON
  ip, ipv4                - IPv4 address
  port                    - Port number (1-65535)
  enum                    - Enum value (requires type_param)
  uuid                    - UUID format
  semver, version         - Semantic version
  hostname                - Valid hostname
  array                   - Array (marker type)
  object                  - Object (marker type)
  any                     - Any value (always valid)

Constraint Validation:
  validate-constraint <value> <constraint_string>

Supported Constraints:
  min:<value>             - Minimum value
  max:<value>             - Maximum value
  range:<min>-<max>       - Range (min to max)
  minlength:<length>      - Minimum string length
  maxlength:<length>      - Maximum string length
  length:<length>         - Exact string length
  pattern:<regex>         - Regex pattern match

Constraint String Format:
  Multiple constraints separated by commas:
    "min:1,max:100"
    "minlength:3,maxlength:50"
    "pattern:^[a-z]+$,minlength:5"

Required Field Validation:
  validate-required <data> <fields>

  where <fields> is comma-separated: "name,version,type"

Custom Validators:
  validate-register <type> <function>     Register custom validator
  validate-unregister <type>              Unregister custom validator
  validate-list-custom                    List registered validators

Utilities:
  validate-get-error                      Get last validation error
  validate-clear-error                    Clear last error
  validate-normalize-bool <value>         Normalize boolean value
  validate-stats                          Show statistics

Examples:
  # Type validation
  validate-type "42" "integer"
  validate-type "user@example.com" "email"
  validate-type "red" "enum" "red|green|blue"

  # Constraint validation
  validate-constraint "5" "min:1,max:10"
  validate-constraint "hello" "minlength:3,maxlength:20"

  # Custom validator
  my-validator() { [[ "$1" == "special" ]]; }
  validate-register "my-type" "my-validator"
  validate-type "special" "my-type"

Configuration:
  VALIDATION_VERBOSE=true/false           Verbose output
  VALIDATION_DEBUG=true/false             Debug output
  VALIDATION_STRICT=true/false            Strict mode (error on unknown types)

EOF
}

# ------------------------------
# Script Execution Detection
# ------------------------------

if [[ "${ZSH_EVAL_CONTEXT}" == *:file || "${ZSH_EVAL_CONTEXT}" == "file" ]]; then
    # Sourced, don't run anything
    :
elif [[ "${ZSH_EVAL_CONTEXT}" == "" || "${(%):-%x}" == "$0" ]]; then
    # Executed directly
    case "${1:-help}" in
        help|--help|-h)
            validate-help
            exit 0
            ;;
        stats)
            validate-stats
            exit 0
            ;;
        *)
            echo "Error: Extension must be sourced, not executed directly" >&2
            echo "Usage: source \"$(which _validation)\"" >&2
            echo "For help: $0 help" >&2
            exit 1
            ;;
    esac
fi

# ------------------------------
# Extension Loaded
# ------------------------------

_validation-log-debug "Extension loaded successfully"
