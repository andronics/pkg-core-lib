#!/usr/bin/env zsh

# _server - Simple HTTP server management and utilities
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Usage:
#   source "$(which _server)"
#
# Provides:
#   - Start/stop HTTP servers (Python, PHP, Node)
#   - Port availability checking
#   - Server status monitoring
#   - Connection testing
#   - URL generation
#   - Process lifecycle management
#   - Multiple concurrent servers
#
# Dependencies:
#   - python3 (optional, for Python server)
#   - php (optional, for PHP server)
#   - node (optional, for Node server)
#   - _common (required, for utilities)
#   - _log (optional, for logging)
#   - _lifecycle (optional, for lifecycle management)
#   - _process (optional, for process management)

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${SERVER_LOADED:-}" ]] && return 0

# ------------------------------
# Version
# ------------------------------

declare -gr SERVER_VERSION="1.0.0"
declare -g SERVER_LOADED=1

# ------------------------------
# Load Dependencies
# ------------------------------

# Load _common (required)
if ! typeset -f common-xdg-cache-home >/dev/null 2>&1; then
    if [[ -f "${0:A:h}/_common" ]]; then
        source "${0:A:h}/_common"
    elif command -v _common &>/dev/null; then
        source "$(command -v _common)"
    else
        print -u2 "ERROR: _common is required but not found"
        return 1
    fi
fi

# Load _log (optional, with fallback)
if ! typeset -f log-error >/dev/null 2>&1; then
    if [[ -f "${0:A:h}/_log" ]]; then
        source "${0:A:h}/_log" 2>/dev/null || true
    elif command -v _log &>/dev/null; then
        source "$(command -v _log)" 2>/dev/null || true
    fi
fi

# Fallback log functions
if ! typeset -f log-error >/dev/null 2>&1; then
    log-error() { print -u2 "ERROR: $*"; }
    log-warning() { print -u2 "WARNING: $*"; }
    log-info() { print "INFO: $*"; }
    log-debug() { [[ "${DEBUG:-0}" == "1" ]] && print "DEBUG: $*"; }
fi

# Load _lifecycle (optional)
if ! typeset -f lifecycle-init >/dev/null 2>&1; then
    if [[ -f "${0:A:h}/_lifecycle" ]]; then
        source "${0:A:h}/_lifecycle" 2>/dev/null || true
    elif command -v _lifecycle &>/dev/null; then
        source "$(command -v _lifecycle)" 2>/dev/null || true
    fi
fi

# Load _process (optional)
if ! typeset -f process-wait-for >/dev/null 2>&1; then
    if [[ -f "${0:A:h}/_process" ]]; then
        source "${0:A:h}/_process" 2>/dev/null || true
    elif command -v _process &>/dev/null; then
        source "$(command -v _process)" 2>/dev/null || true
    fi
fi

# ------------------------------
# Configuration
# ------------------------------

# SERVER_DEFAULT_HOST: Default bind address
declare -g SERVER_DEFAULT_HOST="${SERVER_DEFAULT_HOST:-127.0.0.1}"

# SERVER_DEFAULT_PORT: Default server port
declare -g SERVER_DEFAULT_PORT="${SERVER_DEFAULT_PORT:-8080}"

# SERVER_DEFAULT_TYPE: Default server type (python, php, node)
declare -g SERVER_DEFAULT_TYPE="${SERVER_DEFAULT_TYPE:-python}"

# SERVER_PID_DIR: Directory for PID files
declare -g SERVER_PID_DIR="${SERVER_PID_DIR:-$(common-xdg-cache-home)/server/pids}"

# SERVER_LOG_DIR: Directory for log files
declare -g SERVER_LOG_DIR="${SERVER_LOG_DIR:-$(common-xdg-cache-home)/server/logs}"

# SERVER_START_TIMEOUT: Timeout for server startup (seconds)
declare -g SERVER_START_TIMEOUT="${SERVER_START_TIMEOUT:-5}"

# SERVER_STOP_TIMEOUT: Timeout for server stop (seconds)
declare -g SERVER_STOP_TIMEOUT="${SERVER_STOP_TIMEOUT:-5}"

# Create required directories
mkdir -p "$SERVER_PID_DIR" "$SERVER_LOG_DIR" 2>/dev/null

# ------------------------------
# Internal State
# ------------------------------

# Active servers registry: port => type:directory:pid
typeset -gA _SERVER_REGISTRY=()

# ------------------------------
# Lifecycle Integration
# ------------------------------

# Initialize server extension
# Usage: server-init
server-init() {
    log-debug "[server] Initializing v${SERVER_VERSION}"

    # Create directories
    mkdir -p "$SERVER_PID_DIR" "$SERVER_LOG_DIR" 2>/dev/null

    # Clean up stale PID files
    local pid_file
    for pid_file in "$SERVER_PID_DIR"/*.pid(N); do
        local pid=$(<"$pid_file")
        if ! kill -0 "$pid" 2>/dev/null; then
            log-debug "[server] Removing stale PID file: ${pid_file}"
            rm -f "$pid_file"
        fi
    done

    # Register with lifecycle
    if typeset -f lifecycle-register >/dev/null 2>&1; then
        lifecycle-register "server" "$SERVER_VERSION"
    fi

    log-debug "[server] Initialization complete"
    return 0
}

# Cleanup server resources
# Usage: server-cleanup
server-cleanup() {
    log-debug "[server] Cleaning up resources"

    # Stop all running servers
    server-stop-all >/dev/null 2>&1

    _SERVER_REGISTRY=()

    return 0
}

# ------------------------------
# Port Utilities
# ------------------------------

# Check if port is available (not in use)
# Usage: server-is-port-available <port> [host]
server-is-port-available() {
    local port="${1:?Port required}"
    local host="${2:-127.0.0.1}"

    if ! [[ "$port" =~ ^[0-9]+$ ]]; then
        log-error "[server] Invalid port: ${port}"
        return 1
    fi

    # Try to connect - if it fails, port is available
    if command -v nc &>/dev/null; then
        if ! nc -z -w1 "$host" "$port" 2>/dev/null; then
            return 0  # Port available
        else
            return 1  # Port in use
        fi
    else
        # Fallback: check with ss or netstat
        if command -v ss &>/dev/null; then
            ! ss -tuln | grep -q ":${port} "
        elif command -v netstat &>/dev/null; then
            ! netstat -tuln | grep -q ":${port} "
        else
            log-warning "[server] Cannot check port availability (nc/ss/netstat not found)"
            return 0  # Assume available
        fi
    fi
}

# Find available port starting from given port
# Usage: server-find-available-port [start_port]
server-find-available-port() {
    local start_port="${1:-$SERVER_DEFAULT_PORT}"
    local port=$start_port
    local max_attempts=100

    while [[ $max_attempts -gt 0 ]]; do
        if server-is-port-available "$port"; then
            echo "$port"
            return 0
        fi
        ((port++))
        ((max_attempts--))
    done

    log-error "[server] No available ports found (tried ${start_port}-${port})"
    return 1
}

# Get port from PID file
# Usage: server-get-port-from-pid <pid>
server-get-port-from-pid() {
    local pid="${1:?PID required}"

    if command -v ss &>/dev/null; then
        ss -tlnp 2>/dev/null | grep "pid=${pid}" | grep -oP ':\K[0-9]+(?= )'
    elif command -v netstat &>/dev/null; then
        netstat -tlnp 2>/dev/null | grep "${pid}/" | grep -oP ':\K[0-9]+(?= )'
    else
        return 1
    fi
}

# ------------------------------
# Server Type Detection
# ------------------------------

# Check if server type is available
# Usage: server-check-type <type>
server-check-type() {
    local type="${1:?Server type required}"

    case "$type" in
        python|python3)
            command -v python3 &>/dev/null
            ;;
        php)
            command -v php &>/dev/null
            ;;
        node|nodejs)
            command -v node &>/dev/null
            ;;
        *)
            log-error "[server] Unknown server type: ${type}"
            return 1
            ;;
    esac
}

# Get available server types
# Usage: server-list-available-types
server-list-available-types() {
    local -a types=()

    command -v python3 &>/dev/null && types+=("python")
    command -v php &>/dev/null && types+=("php")
    command -v node &>/dev/null && types+=("node")

    if [[ ${#types[@]} -eq 0 ]]; then
        log-warning "[server] No server types available"
        return 1
    fi

    print -l "${types[@]}"
}

# ------------------------------
# Server Management
# ------------------------------

# Start HTTP server
# Usage: server-start [directory] [--port <port>] [--host <host>] [--type <type>]
server-start() {
    local directory="${1:-.}"
    shift 2>/dev/null || true

    local port="$SERVER_DEFAULT_PORT"
    local host="$SERVER_DEFAULT_HOST"
    local type="$SERVER_DEFAULT_TYPE"

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port)
                port="$2"
                shift 2
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            --type)
                type="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Validate directory
    if [[ ! -d "$directory" ]]; then
        log-error "[server] Directory not found: ${directory}"
        return 1
    fi

    directory="${directory:A}"  # Absolute path

    # Check if port available
    if ! server-is-port-available "$port" "$host"; then
        log-error "[server] Port ${port} already in use"
        return 1
    fi

    # Check server type
    if ! server-check-type "$type"; then
        log-error "[server] Server type '${type}' not available"
        log-info "[server] Available types: $(server-list-available-types)"
        return 1
    fi

    log-info "[server] Starting ${type} server on ${host}:${port}"
    log-info "[server] Serving directory: ${directory}"

    # Prepare log file
    local log_file="${SERVER_LOG_DIR}/server-${port}.log"
    local pid_file="${SERVER_PID_DIR}/server-${port}.pid"

    # Start server based on type
    case "$type" in
        python|python3)
            (
                cd "$directory"
                python3 -m http.server "$port" --bind "$host" >>"$log_file" 2>&1 &
                echo $! > "$pid_file"
            )
            ;;
        php)
            (
                cd "$directory"
                php -S "${host}:${port}" >>"$log_file" 2>&1 &
                echo $! > "$pid_file"
            )
            ;;
        node|nodejs)
            (
                cd "$directory"
                npx http-server -p "$port" -a "$host" >>"$log_file" 2>&1 &
                echo $! > "$pid_file"
            )
            ;;
    esac

    # Get PID
    local pid=$(<"$pid_file")

    # Wait for server to start
    local elapsed=0
    while [[ $elapsed -lt $SERVER_START_TIMEOUT ]]; do
        if server-test-connection "$host" "$port"; then
            log-info "[server] Server started successfully (PID: ${pid})"
            _SERVER_REGISTRY[$port]="${type}:${directory}:${pid}"
            return 0
        fi
        sleep 0.5
        ((elapsed++))
    done

    log-error "[server] Server failed to start within ${SERVER_START_TIMEOUT}s"
    kill "$pid" 2>/dev/null
    rm -f "$pid_file"
    return 1
}

# Stop server on specific port
# Usage: server-stop <port>
server-stop() {
    local port="${1:?Port required}"

    local pid_file="${SERVER_PID_DIR}/server-${port}.pid"

    if [[ ! -f "$pid_file" ]]; then
        log-warning "[server] No server running on port ${port}"
        return 1
    fi

    local pid=$(<"$pid_file")

    if ! kill -0 "$pid" 2>/dev/null; then
        log-warning "[server] Server process ${pid} not running"
        rm -f "$pid_file"
        unset "_SERVER_REGISTRY[$port]"
        return 1
    fi

    log-info "[server] Stopping server on port ${port} (PID: ${pid})"

    kill "$pid" 2>/dev/null

    # Wait for process to stop
    local elapsed=0
    while [[ $elapsed -lt $SERVER_STOP_TIMEOUT ]]; do
        if ! kill -0 "$pid" 2>/dev/null; then
            log-info "[server] Server stopped successfully"
            rm -f "$pid_file"
            unset "_SERVER_REGISTRY[$port]"
            return 0
        fi
        sleep 0.5
        ((elapsed++))
    done

    log-warning "[server] Server did not stop gracefully, forcing termination"
    kill -9 "$pid" 2>/dev/null
    rm -f "$pid_file"
    unset "_SERVER_REGISTRY[$port]"
    return 0
}

# Restart server
# Usage: server-restart <port>
server-restart() {
    local port="${1:?Port required}"

    log-info "[server] Restarting server on port ${port}"

    local pid_file="${SERVER_PID_DIR}/server-${port}.pid"
    if [[ ! -f "$pid_file" ]]; then
        log-error "[server] No server running on port ${port}"
        return 1
    fi

    # Get server info
    local info="${_SERVER_REGISTRY[$port]}"
    if [[ -z "$info" ]]; then
        log-error "[server] Server info not found for port ${port}"
        return 1
    fi

    local type="${info%%:*}"
    local rest="${info#*:}"
    local directory="${rest%%:*}"

    # Stop and start
    server-stop "$port"
    sleep 1
    server-start "$directory" --port "$port" --type "$type"
}

# Stop all running servers
# Usage: server-stop-all
server-stop-all() {
    log-info "[server] Stopping all servers"

    local pid_file
    for pid_file in "$SERVER_PID_DIR"/server-*.pid(N); do
        local port="${${pid_file:t}#server-}"
        port="${port%.pid}"
        server-stop "$port"
    done

    return 0
}

# ------------------------------
# Server Status
# ------------------------------

# Check if server is running on port
# Usage: server-is-running <port>
server-is-running() {
    local port="${1:?Port required}"

    local pid_file="${SERVER_PID_DIR}/server-${port}.pid"

    if [[ ! -f "$pid_file" ]]; then
        return 1
    fi

    local pid=$(<"$pid_file")
    kill -0 "$pid" 2>/dev/null
}

# Get server PID
# Usage: server-get-pid <port>
server-get-pid() {
    local port="${1:?Port required}"

    local pid_file="${SERVER_PID_DIR}/server-${port}.pid"

    if [[ -f "$pid_file" ]]; then
        cat "$pid_file"
    else
        return 1
    fi
}

# Get server URL
# Usage: server-get-url <port> [host]
server-get-url() {
    local port="${1:?Port required}"
    local host="${2:-$SERVER_DEFAULT_HOST}"

    # Convert localhost to 127.0.0.1 for consistency
    [[ "$host" == "localhost" ]] && host="127.0.0.1"

    echo "http://${host}:${port}/"
}

# List all running servers
# Usage: server-list
server-list() {
    local any_servers=0

    print "Running Servers:"

    local pid_file
    for pid_file in "$SERVER_PID_DIR"/server-*.pid(N); do
        local port="${${pid_file:t}#server-}"
        port="${port%.pid}"

        if server-is-running "$port"; then
            local pid=$(server-get-pid "$port")
            local url=$(server-get-url "$port")
            local info="${_SERVER_REGISTRY[$port]:-unknown}"
            local type="${info%%:*}"

            print "  Port ${port}: ${type} (PID: ${pid}) - ${url}"
            any_servers=1
        fi
    done

    if [[ $any_servers -eq 0 ]]; then
        print "  (none)"
    fi
}

# Show server status
# Usage: server-status [port]
server-status() {
    local port="${1:-}"

    if [[ -n "$port" ]]; then
        # Show status for specific port
        print "Server Status (Port ${port}):"
        if server-is-running "$port"; then
            local pid=$(server-get-pid "$port")
            local url=$(server-get-url "$port")
            local info="${_SERVER_REGISTRY[$port]:-unknown}"
            local type="${info%%:*}"
            local rest="${info#*:}"
            local directory="${rest%%:*}"

            print "  Status:      Running"
            print "  PID:         ${pid}"
            print "  Type:        ${type}"
            print "  Directory:   ${directory}"
            print "  URL:         ${url}"
        else
            print "  Status:      Not running"
        fi
    else
        # Show all servers
        server-list
    fi
}

# ------------------------------
# Connection Testing
# ------------------------------

# Test connection to server
# Usage: server-test-connection <host> <port>
server-test-connection() {
    local host="${1:?Host required}"
    local port="${2:?Port required}"

    if command -v nc &>/dev/null; then
        nc -z -w1 "$host" "$port" 2>/dev/null
    elif command -v curl &>/dev/null; then
        curl -sf -m1 "http://${host}:${port}/" >/dev/null 2>&1
    else
        log-warning "[server] Cannot test connection (nc/curl not found)"
        return 1
    fi
}

# Wait for server to be ready
# Usage: server-wait-for-ready <host> <port> [timeout]
server-wait-for-ready() {
    local host="${1:?Host required}"
    local port="${2:?Port required}"
    local timeout="${3:-$SERVER_START_TIMEOUT}"

    log-debug "[server] Waiting for ${host}:${port} (timeout: ${timeout}s)"

    local elapsed=0
    while [[ $elapsed -lt $timeout ]]; do
        if server-test-connection "$host" "$port"; then
            log-debug "[server] Server ready at ${host}:${port}"
            return 0
        fi
        sleep 0.5
        ((elapsed++))
    done

    log-error "[server] Timeout waiting for ${host}:${port}"
    return 1
}

# ------------------------------
# Module Info & Help
# ------------------------------

# Show version
# Usage: server-version
server-version() {
    print "lib/_server version ${SERVER_VERSION}"
}

# Show module information
# Usage: server-info
server-info() {
    cat <<EOF
Server Manager v${SERVER_VERSION}

Configuration:
  Default Host:     ${SERVER_DEFAULT_HOST}
  Default Port:     ${SERVER_DEFAULT_PORT}
  Default Type:     ${SERVER_DEFAULT_TYPE}
  PID Directory:    ${SERVER_PID_DIR}
  Log Directory:    ${SERVER_LOG_DIR}

Available Types:
$(server-list-available-types 2>/dev/null | sed 's/^/  /' || echo "  (none)")

Active Servers:
$(server-list | tail -n +2)
EOF
}

# Show help
# Usage: server-help
server-help() {
    cat <<'EOF'
Server Manager - Simple HTTP server management

USAGE:
    source "$(which _server)"

LIFECYCLE:
    server-init                         Initialize server manager
    server-cleanup                      Cleanup resources

SERVER MANAGEMENT:
    server-start [dir] [options]        Start server
      --port <port>                     Specify port (default: 8080)
      --host <host>                     Specify host (default: 127.0.0.1)
      --type <type>                     Server type (python/php/node)
    server-stop <port>                  Stop server on port
    server-restart <port>               Restart server
    server-stop-all                     Stop all servers

SERVER STATUS:
    server-is-running <port>            Check if server running
    server-get-pid <port>               Get server PID
    server-get-url <port> [host]        Get server URL
    server-list                         List all running servers
    server-status [port]                Show server status

PORT UTILITIES:
    server-is-port-available <port> [host]
    server-find-available-port [start]
    server-get-port-from-pid <pid>

CONNECTION TESTING:
    server-test-connection <host> <port>
    server-wait-for-ready <host> <port> [timeout]

SERVER TYPES:
    server-check-type <type>            Check if type available
    server-list-available-types         List available types

INFO:
    server-version                      Show version
    server-info                         Show information
    server-help                         Show this help

EXAMPLES:
    # Start Python server in current directory
    server-start . --port 8080 --type python

    # Start PHP server on custom port
    server-start /var/www --port 8000 --type php

    # Find available port and start server
    port=$(server-find-available-port 8000)
    server-start . --port $port

    # Check status
    server-status 8080

    # Stop server
    server-stop 8080

    # Stop all servers
    server-stop-all

ENVIRONMENT VARIABLES:
    SERVER_DEFAULT_HOST         Default bind address
    SERVER_DEFAULT_PORT         Default port
    SERVER_DEFAULT_TYPE         Default server type
    SERVER_START_TIMEOUT        Startup timeout (seconds)
    SERVER_STOP_TIMEOUT         Stop timeout (seconds)
EOF
}

# ------------------------------
# Self-Test
# ------------------------------

# Run self-test
# Usage: server-self-test
server-self-test() {
    print "=== Testing lib/_server v${SERVER_VERSION} ==="
    print ""

    local tests_passed=0
    local tests_failed=0

    # Test 1: Initialization
    print -n "Test 1: Initialization... "
    if server-init >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Test 2: Check available types
    print -n "Test 2: Available server types... "
    if server-list-available-types >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Test 3: Find available port
    print -n "Test 3: Find available port... "
    local port=$(server-find-available-port 9000 2>/dev/null)
    if [[ -n "$port" ]] && [[ "$port" =~ ^[0-9]+$ ]]; then
        print "PASS (found: ${port})"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Test 4: Port availability check
    print -n "Test 4: Port availability... "
    if server-is-port-available 9999; then
        print "PASS"
        ((tests_passed++))
    else
        print "PASS (port in use)"
        ((tests_passed++))
    fi

    # Test 5: Get URL
    print -n "Test 5: Generate URL... "
    local url=$(server-get-url 8080)
    if [[ "$url" == "http://127.0.0.1:8080/" ]]; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL (got: ${url})"
        ((tests_failed++))
    fi

    # Test 6: Server listing (empty)
    print -n "Test 6: List servers (empty)... "
    if server-list >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Test 7: Server status (not running)
    print -n "Test 7: Status check (not running)... "
    if ! server-is-running 9999; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL (server unexpectedly running)"
        ((tests_failed++))
    fi

    # Test 8: Get PID (nonexistent)
    print -n "Test 8: Get PID (nonexistent)... "
    if ! server-get-pid 9999 >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Test 9: Check server type
    print -n "Test 9: Check server type... "
    if server-check-type "python" >/dev/null 2>&1 || server-check-type "php" >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "SKIP (no server types available)"
        ((tests_passed++))
    fi

    # Test 10: Cleanup
    print -n "Test 10: Cleanup... "
    if server-cleanup >/dev/null 2>&1; then
        print "PASS"
        ((tests_passed++))
    else
        print "FAIL"
        ((tests_failed++))
    fi

    # Summary
    print ""
    print "=== Test Summary ==="
    print "Passed: ${tests_passed}/10"
    print "Failed: ${tests_failed}/10"

    if [[ $tests_failed -eq 0 ]]; then
        print "Status: ALL TESTS PASSED"
        return 0
    else
        print "Status: SOME TESTS FAILED"
        return 1
    fi
}