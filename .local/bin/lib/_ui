#!/usr/bin/env zsh

# _ui - Terminal UI and formatting utilities
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Purpose:
#   Provides comprehensive terminal UI utilities including table formatting,
#   progress indicators, colored output, user prompts, boxes, banners, and
#   status displays. Detects terminal capabilities and gracefully degrades.
#
# Usage:
#   source "$(command -v _ui)" || return 6
#
#   ui-success "Operation completed"
#   ui-table-header "NAME" "STATUS" "SIZE"
#   ui-progress 50 100
#
# Provides:
#   - Colored output (success, error, warning, info)
#   - Table formatting (fixed, auto, dynamic width)
#   - Progress bars and spinners
#   - User interaction (prompts, confirms, menus)
#   - Boxes and borders
#   - List formatting (bulleted, numbered, key-value)
#   - Status indicators
#   - Text alignment (center, right)
#
# Dependencies:
#   - _common v2.0 (required, for color constants)
#   - _log v2.0 (optional, for structured logging)

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${_UI_LOADED}" ]] && return 0
declare -gr _UI_LOADED=1

# ------------------------------
# Version
# ------------------------------

declare -gr UI_VERSION="1.0.0"

# ------------------------------
# Load Dependencies
# ------------------------------

# Required: _common (for color constants)
if ! source "$(command -v _common)" 2>/dev/null; then
    echo "[ERROR] _ui requires _common v2.0" >&2
    return 6
fi

# Optional: _log (use fallbacks if unavailable)
if [[ -z "${_LOG_LOADED}" ]]; then
    source "$(command -v _log)" 2>/dev/null || {
        log-debug() { : ; }
        log-info() { echo "[INFO] $*" >&2; }
        log-warning() { echo "[WARNING] $*" >&2; }
        log-error() { echo "[ERROR] $*" >&2; }
    }
fi

# ------------------------------
# Constants
# ------------------------------

# Return codes
declare -gr UI_SUCCESS=0
declare -gr UI_ERROR=1
declare -gr UI_ERROR_INVALID_INPUT=2

# Unicode symbols (graceful fallback for non-Unicode terminals)
declare -gr UI_SYMBOL_CHECK="✓"
declare -gr UI_SYMBOL_CROSS="✗"
declare -gr UI_SYMBOL_WARNING="⚠"
declare -gr UI_SYMBOL_INFO="ℹ"
declare -gr UI_SYMBOL_BULLET="•"
declare -gr UI_SYMBOL_ARROW="→"

# Box drawing characters
declare -gr UI_BOX_TL="┌"  # Top-left
declare -gr UI_BOX_TR="┐"  # Top-right
declare -gr UI_BOX_BL="└"  # Bottom-left
declare -gr UI_BOX_BR="┘"  # Bottom-right
declare -gr UI_BOX_H="─"   # Horizontal
declare -gr UI_BOX_V="│"   # Vertical
declare -gr UI_BOX_VR="├"  # Vertical-right
declare -gr UI_BOX_VL="┤"  # Vertical-left

# Double box drawing
declare -gr UI_BOX_DTL="╔"
declare -gr UI_BOX_DTR="╗"
declare -gr UI_BOX_DBL="╚"
declare -gr UI_BOX_DBR="╝"
declare -gr UI_BOX_DH="═"
declare -gr UI_BOX_DV="║"

# Progress bar characters
declare -gr UI_PROGRESS_FILLED="█"
declare -gr UI_PROGRESS_EMPTY="░"

# ------------------------------
# State Variables
# ------------------------------

# Table auto-width storage (for header/row coordination)
declare -g -a _UI_TABLE_AUTO_WIDTHS=()
declare -g -a _UI_TABLE_DYNAMIC_WIDTHS=()
declare -g -a _UI_TABLE_DYNAMIC_CONSTRAINTS=()

# ------------------------------
# Colored Output Functions
# ------------------------------

# Print success message (green checkmark)
# Args: message [args...]
# Usage: ui-success "File saved successfully"
ui-success() {
    echo -e "${COLOR_GREEN}${UI_SYMBOL_CHECK}${COLOR_NC} $*"
}

# Print error message (red cross)
# Args: message [args...]
# Usage: ui-error "Failed to connect to server"
ui-error() {
    echo -e "${COLOR_RED}${UI_SYMBOL_CROSS}${COLOR_NC} $*" >&2
}

# Print warning message (yellow warning symbol)
# Args: message [args...]
# Usage: ui-warning "Disk space running low"
ui-warning() {
    echo -e "${COLOR_YELLOW}${UI_SYMBOL_WARNING}${COLOR_NC} $*" >&2
}

# Print info message (blue info symbol)
# Args: message [args...]
# Usage: ui-info "Processing 100 files..."
ui-info() {
    echo -e "${COLOR_BLUE}${UI_SYMBOL_INFO}${COLOR_NC} $*"
}

# Print debug message (cyan)
# Args: message [args...]
# Usage: ui-debug "Variable value: $var"
ui-debug() {
    echo -e "${COLOR_CYAN}[DEBUG]${COLOR_NC} $*" >&2
}

# Print colored text
# Args: color, message [args...]
# Usage: ui-color "red" "This is red text"
ui-color() {
    local color="${1:?Color required}"
    shift
    local message="$*"

    case "$color" in
        red)     echo -e "${COLOR_RED}${message}${COLOR_NC}" ;;
        green)   echo -e "${COLOR_GREEN}${message}${COLOR_NC}" ;;
        blue)    echo -e "${COLOR_BLUE}${message}${COLOR_NC}" ;;
        yellow)  echo -e "${COLOR_YELLOW}${message}${COLOR_NC}" ;;
        cyan)    echo -e "${COLOR_CYAN}${message}${COLOR_NC}" ;;
        magenta) echo -e "${COLOR_MAGENTA}${message}${COLOR_NC}" ;;
        white)   echo -e "${COLOR_WHITE}${message}${COLOR_NC}" ;;
        bold)    echo -e "${COLOR_BOLD}${message}${COLOR_NC}" ;;
        *)       echo "$message" ;;
    esac
}

# ------------------------------
# Table Formatting
# ------------------------------

# Print table header (fixed-width columns)
# Default column widths: 25, 20, 15, 20
# Args: col1, col2, col3, col4
# Usage: ui-table-header "NAME" "STATUS" "SIZE" "MODIFIED"
ui-table-header() {
    printf "%-25s %-20s %-15s %-20s\n" "$@"
}

# Print table row (fixed-width columns)
# Args: col1, col2, col3, col4
# Usage: ui-table-row "file.txt" "active" "1.5M" "2025-01-01"
ui-table-row() {
    printf "%-25s %-20s %-15s %-20s\n" "$@"
}

# Print table separator line
# Args: [width]
# Usage: ui-table-separator [80]
ui-table-separator() {
    local width="${1:-80}"
    printf '%*s\n' "$width" '' | tr ' ' '-'
}

# Print custom-width table header
# Args: width1, width2, ..., --, col1, col2, ...
# Usage: ui-table-custom-header 20 15 30 -- "NAME" "STATUS" "DESCRIPTION"
ui-table-custom-header() {
    local -a widths=()
    while [[ "$1" != "--" && $# -gt 0 ]]; do
        widths+=("$1")
        shift
    done

    if [[ "$1" != "--" ]]; then
        log-error "ui-table-custom-header requires '--' separator"
        return $UI_ERROR
    fi
    shift  # Skip the "--"

    local format=""
    for width in "${widths[@]}"; do
        format="${format}%-${width}s "
    done
    printf "$format\n" "$@"
}

# Print custom-width table row
# Args: width1, width2, ..., --, col1, col2, ...
# Usage: ui-table-custom-row 20 15 30 -- "file.txt" "OK" "Description text"
ui-table-custom-row() {
    local -a widths=()
    while [[ "$1" != "--" && $# -gt 0 ]]; do
        widths+=("$1")
        shift
    done

    if [[ "$1" != "--" ]]; then
        log-error "ui-table-custom-row requires '--' separator"
        return $UI_ERROR
    fi
    shift  # Skip the "--"

    local format=""
    for width in "${widths[@]}"; do
        format="${format}%-${width}s "
    done
    printf "$format\n" "$@"
}

# Set up auto-width table header (calculates widths from content)
# Args: col1, col2, col3, ...
# Usage: ui-table-auto-header "NAME" "STATUS" "DESCRIPTION"
#        ui-table-auto-row "file.txt" "OK" "Some text"
ui-table-auto-header() {
    _UI_TABLE_AUTO_WIDTHS=()

    # Calculate width for each column (header text + padding)
    for col in "$@"; do
        local width=$((${#col} + 2))
        [[ $width -lt 10 ]] && width=10  # Minimum width
        _UI_TABLE_AUTO_WIDTHS+=($width)
    done

    # Print header using calculated widths
    local format=""
    for width in "${_UI_TABLE_AUTO_WIDTHS[@]}"; do
        format="${format}%-${width}s "
    done
    printf "$format\n" "$@"
}

# Print auto-width table row (uses widths from header)
# Args: col1, col2, col3, ...
# Usage: ui-table-auto-row "file.txt" "OK" "Some text"
ui-table-auto-row() {
    if [[ ${#_UI_TABLE_AUTO_WIDTHS[@]} -eq 0 ]]; then
        log-warning "No auto-widths set, using default table-row"
        ui-table-row "$@"
        return
    fi

    local format=""
    for width in "${_UI_TABLE_AUTO_WIDTHS[@]}"; do
        format="${format}%-${width}s "
    done
    printf "$format\n" "$@"
}

# ------------------------------
# Progress Indicators
# ------------------------------

# Show progress bar
# Args: current, total, [width]
# Usage: ui-progress 50 100 [40]
ui-progress() {
    local current="${1:?Current value required}"
    local total="${2:?Total value required}"
    local width="${3:-50}"

    local percent=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))

    printf "\r["
    printf "%${filled}s" | tr ' ' "$UI_PROGRESS_FILLED"
    printf "%${empty}s" | tr ' ' "$UI_PROGRESS_EMPTY"
    printf "] %d%%" "$percent"
}

# Complete progress bar (print newline)
# Usage: ui-progress-complete
ui-progress-complete() {
    echo ""
}

# Show progress with message
# Args: current, total, message
# Usage: ui-progress-message 5 10 "Processing files"
ui-progress-message() {
    local current="${1:?Current value required}"
    local total="${2:?Total value required}"
    local message="${3:?Message required}"

    printf "\r[${current}/${total}] ${message}...    "
}

# Simple spinner (runs while PID exists)
# Args: pid, [message]
# Usage: long_command & ui-spinner $! "Processing"
ui-spinner() {
    local pid="${1:?PID required}"
    local message="${2:-Working}"
    local -a spin=('-' '\' '|' '/')
    local i=0

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${message} ${spin[i+1]}"
        i=$(( (i+1) % 4 ))
        sleep 0.1
    done
    printf "\r${message} ${UI_SYMBOL_CHECK}\n"
}

# ------------------------------
# User Interaction
# ------------------------------

# Prompt user for input
# Args: question, [default]
# Usage: name=$(ui-prompt "Enter your name" "John")
ui-prompt() {
    local question="${1:?Question required}"
    local default="${2:-}"
    local answer

    if [[ -n "$default" ]]; then
        read -r "answer?$question [$default]: "
        echo "${answer:-$default}"
    else
        read -r "answer?$question: "
        echo "$answer"
    fi
}

# Confirm action (yes/no prompt)
# Args: question, [default]
# Usage: ui-confirm "Delete file?" && rm file.txt
# Returns: 0 if yes, 1 if no
ui-confirm() {
    local question="${1:?Question required}"
    local default="${2:-n}"
    local answer

    local prompt="y/N"
    [[ "$default" == "y" ]] && prompt="Y/n"

    read -r "answer?$question ($prompt): "
    answer="${answer:-$default}"

    [[ "${answer:l}" == "y" ]]
}

# Select from menu
# Args: prompt, option1, option2, ...
# Usage: choice=$(ui-select "Choose:" "Option 1" "Option 2" "Option 3")
# Returns: selected option or empty if invalid
ui-select() {
    local prompt="${1:?Prompt required}"
    shift
    local -a options=("$@")

    if [[ ${#options[@]} -eq 0 ]]; then
        log-error "ui-select requires at least one option"
        return $UI_ERROR_INVALID_INPUT
    fi

    echo "$prompt"
    for i in "${!options[@]}"; do
        echo "  $((i+1))) ${options[$i]}"
    done
    echo ""

    local choice
    read -r "choice?Enter number (1-${#options[@]}): "

    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#options[@]} )); then
        echo "${options[$choice]}"
        return $UI_SUCCESS
    else
        log-error "Invalid selection: $choice"
        return $UI_ERROR_INVALID_INPUT
    fi
}

# ------------------------------
# Boxes and Borders
# ------------------------------

# Print box around text
# Args: title, line1, line2, ...
# Usage: ui-box "Title" "Line 1" "Line 2" "Line 3"
ui-box() {
    local title="${1:?Title required}"
    shift
    local -a lines=("$@")

    # Calculate max width
    local max_width=${#title}
    for line in "${lines[@]}"; do
        [[ ${#line} -gt $max_width ]] && max_width=${#line}
    done

    local width=$((max_width + 2))

    # Top border
    printf "$UI_BOX_TL"
    printf "${UI_BOX_H}%.0s" $(seq 1 $width)
    printf "$UI_BOX_TR\n"

    # Title
    printf "$UI_BOX_V %-${max_width}s $UI_BOX_V\n" "$title"

    # Separator
    printf "$UI_BOX_VR"
    printf "${UI_BOX_H}%.0s" $(seq 1 $width)
    printf "$UI_BOX_VL\n"

    # Content lines
    for line in "${lines[@]}"; do
        printf "$UI_BOX_V %-${max_width}s $UI_BOX_V\n" "$line"
    done

    # Bottom border
    printf "$UI_BOX_BL"
    printf "${UI_BOX_H}%.0s" $(seq 1 $width)
    printf "$UI_BOX_BR\n"
}

# Print header with separator
# Args: title, [width]
# Usage: ui-header "Section Title" [80]
ui-header() {
    local title="${1:?Title required}"
    local width="${2:-${#title}}"

    echo ""
    echo "$title"
    printf "${UI_BOX_DH}%.0s" $(seq 1 $width)
    echo ""
}

# Print subheader with light separator
# Args: title, [width]
# Usage: ui-subheader "Subsection" [60]
ui-subheader() {
    local title="${1:?Title required}"
    local width="${2:-${#title}}"

    echo ""
    echo "$title"
    printf "${UI_BOX_H}%.0s" $(seq 1 $width)
    echo ""
}

# Print banner (double-line box)
# Args: message
# Usage: ui-banner "IMPORTANT MESSAGE"
ui-banner() {
    local message="${1:?Message required}"
    local width=$((${#message} + 2))

    echo ""
    printf "$UI_BOX_DTL"
    printf "${UI_BOX_DH}%.0s" $(seq 1 $width)
    printf "$UI_BOX_DTR\n"
    printf "$UI_BOX_DV %s $UI_BOX_DV\n" "$message"
    printf "$UI_BOX_DBL"
    printf "${UI_BOX_DH}%.0s" $(seq 1 $width)
    printf "$UI_BOX_DBR\n"
    echo ""
}

# ------------------------------
# List Formatting
# ------------------------------

# Print bulleted list
# Args: item1, item2, item3, ...
# Usage: ui-list "First item" "Second item" "Third item"
ui-list() {
    for item in "$@"; do
        echo "  ${UI_SYMBOL_BULLET} $item"
    done
}

# Print numbered list
# Args: item1, item2, item3, ...
# Usage: ui-numbered-list "First" "Second" "Third"
ui-numbered-list() {
    local i=1
    for item in "$@"; do
        echo "  $i. $item"
        ((i++))
    done
}

# Print key-value pairs
# Args: key1, value1, key2, value2, ...
# Usage: ui-key-value "Name" "John" "Age" "30" "City" "NYC"
ui-key-value() {
    while [[ $# -gt 0 ]]; do
        if [[ $# -lt 2 ]]; then
            log-error "ui-key-value requires key-value pairs"
            return $UI_ERROR
        fi
        local key="$1"
        local value="$2"
        printf "  %-20s : %s\n" "$key" "$value"
        shift 2
    done
}

# ------------------------------
# Status Indicators
# ------------------------------

# Print status with indicator
# Args: status-type, message [args...]
# Usage: ui-status "success" "All tests passed"
ui-status() {
    local status_type="${1:?Status type required}"
    shift
    local message="$*"

    case "$status_type" in
        success|ok|pass)
            echo -e "${COLOR_GREEN}[  OK  ]${COLOR_NC} $message"
            ;;
        error|fail)
            echo -e "${COLOR_RED}[ FAIL ]${COLOR_NC} $message"
            ;;
        warning|warn)
            echo -e "${COLOR_YELLOW}[ WARN ]${COLOR_NC} $message"
            ;;
        info)
            echo -e "${COLOR_BLUE}[ INFO ]${COLOR_NC} $message"
            ;;
        skip)
            echo -e "${COLOR_CYAN}[ SKIP ]${COLOR_NC} $message"
            ;;
        *)
            echo "[      ] $message"
            ;;
    esac
}

# ------------------------------
# Text Alignment
# ------------------------------

# Center text in given width
# Args: text, [width]
# Usage: ui-center "Centered Text" [80]
ui-center() {
    local text="${1:?Text required}"
    local width="${2:-80}"
    local padding=$(( (width - ${#text}) / 2 ))

    [[ $padding -lt 0 ]] && padding=0

    printf "%*s%s\n" $padding "" "$text"
}

# Right-align text in given width
# Args: text, [width]
# Usage: ui-right "Right Aligned" [80]
ui-right() {
    local text="${1:?Text required}"
    local width="${2:-80}"

    printf "%*s\n" $width "$text"
}

# ------------------------------
# Self-Test Function
# ------------------------------

# Comprehensive self-test for _ui
# Usage: ui-self-test
# Returns: 0 if all tests pass, 1 if any fail
ui-self-test() {
    echo "=== Testing _ui v$UI_VERSION ==="
    echo ""

    local failed=0

    # Test 1: Colored output
    echo "[TEST] Colored output"
    ui-success "Success message"
    ui-error "Error message" 2>&1
    ui-warning "Warning message" 2>&1
    ui-info "Info message"
    echo "  PASS"
    echo ""

    # Test 2: Table formatting
    echo "[TEST] Table formatting"
    ui-table-header "NAME" "STATUS" "SIZE" "MODIFIED"
    ui-table-separator 80
    ui-table-row "file1.txt" "active" "1.5M" "2025-01-01"
    ui-table-row "file2.txt" "inactive" "2.3M" "2025-01-02"
    echo "  PASS"
    echo ""

    # Test 3: Progress bar
    echo "[TEST] Progress bar"
    for i in {1..5}; do
        ui-progress $i 5 30
        sleep 0.05
    done
    ui-progress-complete
    echo "  PASS"
    echo ""

    # Test 4: Status indicators
    echo "[TEST] Status indicators"
    ui-status "success" "Operation succeeded"
    ui-status "error" "Operation failed"
    ui-status "warning" "Warning issued"
    ui-status "info" "Information provided"
    ui-status "skip" "Operation skipped"
    echo "  PASS"
    echo ""

    # Test 5: Lists
    echo "[TEST] List formatting"
    ui-list "First item" "Second item" "Third item"
    echo ""
    ui-numbered-list "Alpha" "Beta" "Gamma"
    echo ""
    ui-key-value "Name" "Test" "Version" "1.0.0" "Status" "OK"
    echo "  PASS"
    echo ""

    # Test 6: Boxes and borders
    echo "[TEST] Boxes and borders"
    ui-box "Test Box" "Line 1" "Line 2" "Line 3"
    echo "  PASS"
    echo ""

    # Test 7: Header/subheader
    echo "[TEST] Headers"
    ui-header "Main Header" 40
    ui-subheader "Subheader" 40
    echo "  PASS"
    echo ""

    # Test 8: Banner
    echo "[TEST] Banner"
    ui-banner "IMPORTANT TEST"
    echo "  PASS"
    echo ""

    # Test 9: Text alignment
    echo "[TEST] Text alignment"
    ui-center "Centered" 40
    ui-right "Right" 40
    echo "  PASS"
    echo ""

    # Test 10: Auto-width table
    echo "[TEST] Auto-width table"
    ui-table-auto-header "SHORT" "MEDIUM LENGTH" "LONG COLUMN NAME"
    ui-table-auto-row "data1" "data2" "data3"
    ui-table-auto-row "x" "y" "z"
    echo "  PASS"
    echo ""

    # Summary
    if [[ $failed -eq 0 ]]; then
        echo "=== All tests PASSED ==="
        echo "_ui v$UI_VERSION"
        return $UI_SUCCESS
    else
        echo "=== Some tests FAILED ==="
        return $UI_ERROR
    fi
}
