#!/usr/bin/env zsh
# _plugins - Plugin discovery, loading, and initialization system
# Version: 1.0.0
# Dependencies: _common, _log (optional), _events (optional), _schema, _actions

# Prevent multiple sourcing
[[ -n "${_PLUGINS_LOADED:-}" ]] && return 0
declare -g _PLUGINS_LOADED=1

# Load dependencies
source "$(which _common)" 2>/dev/null || {
    echo "Error: _plugins requires _common library" >&2
    return 1
}
source "$(which _schema)" 2>/dev/null || {
    echo "Error: _plugins requires _schema library" >&2
    return 1
}
source "$(which _actions)" 2>/dev/null || {
    echo "Error: _plugins requires _actions library" >&2
    return 1
}
source "$(which _log)" 2>/dev/null || true
source "$(which _events)" 2>/dev/null || true

###########################################
# Plugin System State
###########################################

# Plugin registry: name => metadata_json
declare -g -A _PLUGINS_REGISTRY=()

# Plugin state: name => state (discovered|loaded|initialized|failed)
declare -g -A _PLUGINS_STATE=()

# Plugin paths: name => directory_path
declare -g -A _PLUGINS_PATHS=()

# Plugin dependencies: name => array of dependency names
declare -g -A _PLUGINS_DEPS=()

# Initialization order (populated after dependency resolution)
declare -g -a _PLUGINS_INIT_ORDER=()

###########################################
# Configuration
###########################################

# Plugin search paths (configurable)
declare -g PLUGINS_SEARCH_PATHS=(
    "${HOME}/.local/libexec/plugins"
    "${XDG_DATA_HOME:-$HOME/.local/share}/plugins"
    "/usr/local/libexec/plugins"
)

# Plugin enable/disable directory
declare -g PLUGINS_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/plugins"

###########################################
# Plugin Discovery
###########################################

# plugin-discover [search_path]
# Discover all plugins in search paths or specified path
# Returns: 0 on success, 1 on error
plugin-discover() {
    local search_path="${1:-}"
    local paths=()

    if [[ -n "$search_path" ]]; then
        paths=("$search_path")
    else
        paths=("${PLUGINS_SEARCH_PATHS[@]}")
    fi

    echo "[DEBUG plugin-discover] Search paths: ${paths[@]}" >&2

    local discovered=0
    for path in "${paths[@]}"; do
        echo "[DEBUG plugin-discover] Checking path: $path" >&2
        if [[ ! -d "$path" ]]; then
            echo "[DEBUG plugin-discover] Path does not exist: $path" >&2
            continue
        fi
        echo "[DEBUG plugin-discover] Path exists, searching for plugin files..." >&2

        # Find all plugin.yaml/yml files using zsh globs
        local plugin_file
        for plugin_file in "$path"/**/plugin.{yaml,yml}(N); do
            echo "[DEBUG plugin-discover] Found candidate: $plugin_file" >&2
            [[ ! -f "$plugin_file" ]] && continue

            # Use zsh parameter expansion instead of external commands
            local plugin_dir="${plugin_file:h}"      # :h removes filename (dirname)
            local plugin_name="${plugin_dir:t}"      # :t gets tail (basename)

            echo "[DEBUG plugin-discover] Loading metadata for: $plugin_name from $plugin_file" >&2
            if _plugin-load-metadata "$plugin_name" "$plugin_file"; then
                ((discovered++))
                _PLUGINS_STATE[$plugin_name]="discovered"
                _PLUGINS_PATHS[$plugin_name]="$plugin_dir"

                echo "[DEBUG plugin-discover] Successfully loaded plugin: $plugin_name" >&2
                [[ -n "${_LOG_LOADED:-}" ]] && \
                    log-debug "Discovered plugin: $plugin_name at $plugin_dir"
            else
                echo "[DEBUG plugin-discover] Failed to load metadata for: $plugin_name" >&2
                [[ -n "${_LOG_LOADED:-}" ]] && \
                    log-warn "Failed to load plugin metadata: $plugin_name"
            fi
        done
    done

    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Discovered $discovered plugins"

    return 0
}

# _plugin-load-metadata <name> <plugin_file>
# Load and validate plugin metadata from plugin.yaml
# Returns: 0 on success, 1 on error
_plugin-load-metadata() {
    local name="$1"
    local plugin_file="$2"

    # Load as schema (supports YAML/JSON)
    local metadata
    metadata="$(schema-load-file "$plugin_file")" || return 1

    # Validate required fields
    local plugin_name version
    plugin_name="$(echo "$metadata" | /usr/bin/jq -r '.name // empty')"
    version="$(echo "$metadata" | /usr/bin/jq -r '.version // empty')"

    if [[ -z "$plugin_name" || -z "$version" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin metadata missing required fields: name, version"
        return 1
    fi

    # Store metadata
    _PLUGINS_REGISTRY[$name]="$metadata"

    # Extract dependencies
    local deps
    deps="$(echo "$metadata" | /usr/bin/jq -r '.dependencies[]? // empty')"
    if [[ -n "$deps" ]]; then
        _PLUGINS_DEPS[$name]="$deps"
    fi

    return 0
}

###########################################
# Plugin Metadata Queries
###########################################

# plugin-get-metadata <name>
# Get full metadata JSON for a plugin
plugin-get-metadata() {
    local name="$1"

    if [[ -z "${_PLUGINS_REGISTRY[$name]:-}" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin not found: $name"
        return 1
    fi

    echo "${_PLUGINS_REGISTRY[$name]}"
}

# plugin-get <name> <field> [default]
# Get a specific field from plugin metadata
plugin-get() {
    local name="$1"
    local field="$2"
    local default="${3:-}"

    local metadata
    metadata="$(plugin-get-metadata "$name" 2>/dev/null)" || {
        echo "$default"
        return 1
    }

    local value
    value="$(echo "$metadata" | /usr/bin/jq -r ".$field // empty")"

    if [[ -z "$value" ]]; then
        echo "$default"
        return 1
    fi

    echo "$value"
}

# plugin-list [state_filter]
# List all plugins, optionally filtered by state
plugin-list() {
    local state_filter="${1:-}"

    for name in "${(@k)_PLUGINS_REGISTRY}"; do
        if [[ -z "$state_filter" || "${_PLUGINS_STATE[$name]:-}" == "$state_filter" ]]; then
            echo "$name"
        fi
    done
}

# plugin-get-state <name>
# Get current state of a plugin
plugin-get-state() {
    local name="$1"
    echo "${_PLUGINS_STATE[$name]:-unknown}"
}

###########################################
# Plugin Enable/Disable
###########################################

# plugin-is-enabled <name>
# Check if a plugin is enabled (default: enabled unless explicitly disabled)
# Returns: 0 if enabled, 1 if disabled
plugin-is-enabled() {
    local name="$1"

    # Create config directory if it doesn't exist
    /bin/mkdir -p "$PLUGINS_CONFIG_DIR"

    # Check for disable marker
    if [[ -f "$PLUGINS_CONFIG_DIR/$name.disabled" ]]; then
        return 1
    fi

    # Default: enabled
    return 0
}

# plugin-enable <name>
# Enable a plugin (remove disable marker)
plugin-enable() {
    local name="$1"

    if [[ ! -v "_PLUGINS_REGISTRY[$name]" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Cannot enable unknown plugin: $name"
        return 1
    fi

    /bin/mkdir -p "$PLUGINS_CONFIG_DIR"
    rm -f "$PLUGINS_CONFIG_DIR/$name.disabled"

    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Enabled plugin: $name"

    return 0
}

# plugin-disable <name>
# Disable a plugin (create disable marker)
plugin-disable() {
    local name="$1"

    if [[ ! -v "_PLUGINS_REGISTRY[$name]" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Cannot disable unknown plugin: $name"
        return 1
    fi

    /bin/mkdir -p "$PLUGINS_CONFIG_DIR"
    touch "$PLUGINS_CONFIG_DIR/$name.disabled"

    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Disabled plugin: $name"

    return 0
}

###########################################
# Plugin Loading
###########################################

# plugin-load <name>
# Load plugin code (source the plugin file)
# Returns: 0 on success, 1 on error
plugin-load() {
    local name="$1"

    echo "[DEBUG plugin-load] Loading plugin: $name" >&2

    # Check if already loaded or initialized
    local state="${_PLUGINS_STATE[$name]:-}"
    echo "[DEBUG plugin-load] Current state: '$state'" >&2
    if [[ "$state" == "loaded" || "$state" == "initialized" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-debug "Plugin already loaded: $name"
        echo "[DEBUG plugin-load] Already loaded, returning 0" >&2
        return 0
    fi

    # Check if discovered
    if [[ "$state" != "discovered" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Cannot load plugin not yet discovered: $name"
        echo "[DEBUG plugin-load] State is not 'discovered', failing" >&2
        return 1
    fi

    # Check if enabled
    echo "[DEBUG plugin-load] Checking if enabled..." >&2
    if ! plugin-is-enabled "$name"; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-info "Skipping disabled plugin: $name"
        _PLUGINS_STATE[$name]="disabled"
        echo "[DEBUG plugin-load] Plugin is disabled" >&2
        return 0
    fi
    echo "[DEBUG plugin-load] Plugin is enabled" >&2

    # Get plugin directory
    local plugin_dir="${_PLUGINS_PATHS[$name]:-}"
    echo "[DEBUG plugin-load] Plugin dir: '$plugin_dir'" >&2
    if [[ -z "$plugin_dir" || ! -d "$plugin_dir" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin directory not found: $name"
        _PLUGINS_STATE[$name]="failed"
        echo "[DEBUG plugin-load] Plugin directory not found or not a directory" >&2
        return 1
    fi

    # Find plugin code file
    local plugin_code="$plugin_dir/plugin.zsh"
    echo "[DEBUG plugin-load] Plugin code path: '$plugin_code'" >&2
    if [[ ! -f "$plugin_code" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin code not found: $plugin_code"
        _PLUGINS_STATE[$name]="failed"
        echo "[DEBUG plugin-load] Plugin code file not found" >&2
        return 1
    fi

    # Source plugin code
    echo "[DEBUG plugin-load] Sourcing plugin code..." >&2
    # Temporarily allow stderr to see what's failing
    if source "$plugin_code" >&2; then
        _PLUGINS_STATE[$name]="loaded"
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-info "Loaded plugin: $name"
        echo "[DEBUG plugin-load] Successfully sourced plugin code" >&2

        # Emit event
        [[ -n "${_EVENTS_LOADED:-}" ]] && \
            event-emit "plugin.loaded" "$name"

        return 0
    else
        _PLUGINS_STATE[$name]="failed"
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Failed to load plugin code: $name"
        return 1
    fi
}

###########################################
# Plugin Initialization
###########################################

# plugin-init <name>
# Initialize a plugin (call its init function if it exists)
# Returns: 0 on success, 1 on error
plugin-init() {
    local name="$1"

    echo "[DEBUG plugin-init] Initializing plugin: $name" >&2

    # Ensure plugin is loaded
    local state="${_PLUGINS_STATE[$name]:-}"
    echo "[DEBUG plugin-init] Current state: '$state'" >&2
    if [[ "$state" == "initialized" ]]; then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-debug "Plugin already initialized: $name"
        echo "[DEBUG plugin-init] Already initialized, returning 0" >&2
        return 0
    fi

    if [[ "$state" != "loaded" ]]; then
        echo "[DEBUG plugin-init] Plugin not loaded, calling plugin-load..." >&2
        if ! plugin-load "$name"; then
            echo "[DEBUG plugin-init] plugin-load FAILED" >&2
            return 1
        fi
        echo "[DEBUG plugin-init] plugin-load succeeded" >&2
    fi

    # Check if plugin has init function
    local init_func="${name//-/_}_init"
    if ! typeset -f "$init_func" &>/dev/null; then
        # No init function is OK - just mark as initialized
        _PLUGINS_STATE[$name]="initialized"
        return 0
    fi

    # Call init function
    if "$init_func"; then
        _PLUGINS_STATE[$name]="initialized"
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-info "Initialized plugin: $name"

        # Emit event
        [[ -n "${_EVENTS_LOADED:-}" ]] && \
            event-emit "plugin.initialized" "$name"

        return 0
    else
        _PLUGINS_STATE[$name]="failed"
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin initialization failed: $name"
        return 1
    fi
}

###########################################
# Dependency Resolution
###########################################

# _plugin-get-dep-list <name> [visited...]
# Get dependency-ordered list of plugins (including the plugin itself)
# Outputs one plugin name per line
# Returns: 0 on success, 1 on circular dependency or missing dependency
_plugin-get-dep-list() {
    local name="$1"
    shift
    local -a visited=("$@")

    echo "[DEBUG _plugin-get-dep-list] Called for: $name, visited so far: ${visited[@]}" >&2

    # Check for circular dependency
    if (( ${visited[(I)$name]} )); then
        echo "[ERROR] Circular dependency detected: ${visited[*]} -> $name" >&2
        return 1
    fi

    # Add to visited
    visited+=("$name")

    # Get dependencies
    local deps="${_PLUGINS_DEPS[$name]:-}"
    echo "[DEBUG _plugin-get-dep-list] Dependencies for $name: '$deps'" >&2

    # Recursively resolve each dependency first
    if [[ -n "$deps" ]]; then
        local dep
        while IFS= read -r dep; do
            [[ -z "$dep" ]] && continue

            # Check if dependency exists
            if [[ ! -v "_PLUGINS_REGISTRY[$dep]" ]]; then
                echo "[ERROR] Plugin $name depends on unknown plugin: $dep" >&2
                return 1
            fi

            # Recursively get dependencies (passing visited list)
            _plugin-get-dep-list "$dep" "${visited[@]}" || return 1
        done <<< "$deps"
    fi

    # Output this plugin last (after its dependencies)
    echo "$name"
    return 0
}

# _plugin-resolve-deps <name> <visited_array_name>
# Recursively resolve plugin dependencies (DEPRECATED - use _plugin-get-dep-list)
# Returns: 0 on success, 1 on circular dependency
_plugin-resolve-deps() {
    local name="$1"
    local visited_var="$2"

    echo "[DEBUG _plugin-resolve-deps] Called for plugin: $name, visited_var: $visited_var" >&2

    # Create visited array if it doesn't exist
    if ! typeset -p "$visited_var" &>/dev/null; then
        typeset -g -a "$visited_var=()"
    fi

    # Check for circular dependency
    local -a visited=("${(@P)visited_var}")
    echo "[DEBUG _plugin-resolve-deps] Current visited before adding: ${visited[@]}" >&2
    if (( ${visited[(I)$name]} )); then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Circular dependency detected: ${visited[*]} -> $name"
        return 1
    fi

    # Add to visited
    visited+=("$name")
    # Use typeset -g to ensure we're modifying the global variable
    typeset -g -a "$visited_var"
    eval "$visited_var=(\"\${visited[@]}\")"
    echo "[DEBUG _plugin-resolve-deps] After adding $name to visited (local): ${visited[@]}" >&2
    # Verify the parent variable was updated
    local -a check_visited=("${(@P)visited_var}")
    echo "[DEBUG _plugin-resolve-deps] Parent $visited_var after update: ${check_visited[@]}" >&2

    # Get dependencies
    local deps="${_PLUGINS_DEPS[$name]:-}"
    echo "[DEBUG _plugin-resolve-deps] Dependencies for $name: '$deps'" >&2
    if [[ -z "$deps" ]]; then
        echo "[DEBUG _plugin-resolve-deps] No dependencies, returning 0" >&2
        return 0
    fi

    # Recursively resolve each dependency
    local dep
    while IFS= read -r dep; do
        [[ -z "$dep" ]] && continue

        # Check if dependency exists
        if [[ ! -v "_PLUGINS_REGISTRY[$dep]" ]]; then
            [[ -n "${_LOG_LOADED:-}" ]] && \
                log-error "Plugin $name depends on unknown plugin: $dep"
            return 1
        fi

        # Recursively resolve
        _plugin-resolve-deps "$dep" "$visited_var" || return 1
    done <<< "$deps"

    return 0
}

# plugin-init-all
# Initialize all discovered plugins in dependency order
# Returns: 0 on success, 1 on error
plugin-init-all() {
    local -a init_order=()
    local -a processed=()

    echo "[DEBUG plugin-init-all] _PLUGINS_REGISTRY keys: ${(k)_PLUGINS_REGISTRY[@]}" >&2

    # Build dependency-ordered initialization list
    for name in "${(@k)_PLUGINS_REGISTRY}"; do
        echo "[DEBUG plugin-init-all] Processing plugin: $name" >&2
        # Skip if already processed
        if (( ${processed[(I)$name]} )); then
            echo "[DEBUG plugin-init-all] Already processed: $name" >&2
            continue
        fi

        # Skip if disabled
        echo "[DEBUG plugin-init-all] Checking if enabled: $name" >&2
        if ! plugin-is-enabled "$name"; then
            echo "[DEBUG plugin-init-all] Plugin is DISABLED: $name" >&2
            [[ -n "${_LOG_LOADED:-}" ]] && \
                log-debug "Skipping disabled plugin: $name"
            _PLUGINS_STATE[$name]="disabled"
            continue
        fi
        echo "[DEBUG plugin-init-all] Plugin is enabled: $name" >&2

        # Resolve dependencies - get list of dependencies in order
        echo "[DEBUG plugin-init-all] Resolving dependencies for: $name" >&2
        local dep_list
        dep_list=$(_plugin-get-dep-list "$name") || {
            echo "[DEBUG plugin-init-all] Dependency resolution FAILED for: $name" >&2
            [[ -n "${_LOG_LOADED:-}" ]] && \
                log-error "Failed to resolve dependencies for: $name"
            _PLUGINS_STATE[$name]="failed"
            continue
        }
        echo "[DEBUG plugin-init-all] Dependencies resolved for: $name, list: $dep_list" >&2

        # Add plugin and its dependencies to init order
        local dep
        for dep in ${(f)dep_list}; do
            [[ -z "$dep" ]] && continue
            echo "[DEBUG plugin-init-all] Adding dep to init_order: $dep" >&2
            # Skip if already in init order
            (( ${init_order[(I)$dep]} )) && continue
            init_order+=("$dep")
            processed+=("$dep")
        done
    done

    # Store init order
    _PLUGINS_INIT_ORDER=("${init_order[@]}")

    echo "[DEBUG plugin-init-all] Init order: ${init_order[*]}" >&2
    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Plugin initialization order: ${init_order[*]}"

    # Initialize each plugin in order
    local failed=0
    for name in "${init_order[@]}"; do
        echo "[DEBUG plugin-init-all] Initializing plugin: $name" >&2
        if ! plugin-init "$name"; then
            ((failed++))
            echo "[DEBUG plugin-init-all] Plugin initialization FAILED: $name" >&2
            [[ -n "${_LOG_LOADED:-}" ]] && \
                log-error "Failed to initialize plugin: $name"
        else
            echo "[DEBUG plugin-init-all] Plugin initialization SUCCESS: $name" >&2
        fi
    done

    if (( failed > 0 )); then
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-warn "Plugin initialization completed with $failed failures"
        return 1
    fi

    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Successfully initialized ${#init_order[@]} plugins"

    return 0
}

###########################################
# Plugin Utilities
###########################################

# plugin-get-path <name>
# Get the directory path for a plugin
plugin-get-path() {
    local name="$1"
    echo "${_PLUGINS_PATHS[$name]:-}"
}

# plugin-exists <name>
# Check if a plugin exists (has been discovered)
# Returns: 0 if exists, 1 otherwise
plugin-exists() {
    local name="$1"
    [[ -v "_PLUGINS_REGISTRY[$name]" ]]
}

# plugin-validate <name>
# Validate plugin structure and metadata
# Returns: 0 if valid, 1 otherwise
plugin-validate() {
    local name="$1"

    # Check if exists
    if ! plugin-exists "$name"; then
        echo "Plugin not found: $name"
        return 1
    fi

    # Get metadata
    local metadata
    metadata="$(plugin-get-metadata "$name")" || {
        echo "Failed to get metadata for: $name"
        return 1
    }

    # Check required fields
    local required_fields=("name" "version" "description")
    local field
    for field in "${required_fields[@]}"; do
        local value
        value="$(echo "$metadata" | jq -r ".$field // empty")"
        if [[ -z "$value" ]]; then
            echo "Missing required field '$field' in plugin: $name"
            return 1
        fi
    done

    # Check plugin code exists
    local plugin_path="${_PLUGINS_PATHS[$name]:-}"
    if [[ -z "$plugin_path" || ! -f "$plugin_path/plugin.zsh" ]]; then
        echo "Plugin code not found: $name"
        return 1
    fi

    # Check dependencies exist
    local deps="${_PLUGINS_DEPS[$name]:-}"
    if [[ -n "$deps" ]]; then
        local dep
        while IFS= read -r dep; do
            [[ -z "$dep" ]] && continue
            if ! plugin-exists "$dep"; then
                echo "Plugin $name depends on unknown plugin: $dep"
                return 1
            fi
        done <<< "$deps"
    fi

    echo "Plugin validation passed: $name"
    return 0
}

# plugin-info <name>
# Display detailed information about a plugin
plugin-info() {
    local name="$1"

    if ! plugin-exists "$name"; then
        echo "Plugin not found: $name"
        return 1
    fi

    local metadata
    metadata="$(plugin-get-metadata "$name")"

    echo "Plugin: $name"
    echo "State: ${_PLUGINS_STATE[$name]:-unknown}"
    echo "Path: ${_PLUGINS_PATHS[$name]:-unknown}"
    echo ""
    echo "Metadata:"
    echo "$metadata" | jq '.'

    local deps="${_PLUGINS_DEPS[$name]:-}"
    if [[ -n "$deps" ]]; then
        echo ""
        echo "Dependencies:"
        echo "$deps" | sed 's/^/  - /'
    fi

    return 0
}

###########################################
# Bootstrap Function
###########################################

# plugin-bootstrap
# Discover and initialize all plugins (convenience function)
# Returns: 0 on success, 1 on error
plugin-bootstrap() {
    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Bootstrapping plugin system..."

    # Discover all plugins
    echo "[DEBUG plugin-bootstrap] Calling plugin-discover..." >&2
    plugin-discover || {
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-error "Plugin discovery failed"
        echo "[DEBUG plugin-bootstrap] plugin-discover failed!" >&2
        return 1
    }
    echo "[DEBUG plugin-bootstrap] plugin-discover succeeded, found plugins: ${(k)_PLUGINS_METADATA[@]}" >&2

    # Initialize all plugins
    echo "[DEBUG plugin-bootstrap] Calling plugin-init-all..." >&2
    plugin-init-all || {
        [[ -n "${_LOG_LOADED:-}" ]] && \
            log-warn "Some plugins failed to initialize"
        echo "[DEBUG plugin-bootstrap] plugin-init-all failed!" >&2
        return 1
    }
    echo "[DEBUG plugin-bootstrap] plugin-init-all succeeded" >&2

    [[ -n "${_LOG_LOADED:-}" ]] && \
        log-info "Plugin system ready"

    return 0
}

###########################################
# Export Functions
###########################################

# Note: In zsh, functions are automatically available to subshells
# export -f is not needed and causes errors

[[ -n "${_LOG_LOADED:-}" ]] && \
    log-debug "Plugin system loaded (v1.0.0)"

return 0
