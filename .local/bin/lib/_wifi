#!/usr/bin/env zsh
# =============================================================================
# _wifi - WiFi/Wireless Network Management Library
# =============================================================================
# Part of the dotfiles library v2.0
#
# Provides comprehensive WiFi network management through iwd (iNet Wireless Daemon)
# and iwctl command-line interface. Supports station mode, access point mode,
# ad-hoc networking, network scanning, connection management, and signal monitoring.
#
# Author: andronics
# Version: 1.0.0
# Dependencies: _common (required), iwctl/iwd (required)
# Optional: _log, _events, _cache, _lifecycle, _config
#
# Provides:
# - Device management and discovery
# - Network scanning and discovery
# - Connection management (connect, disconnect, status)
# - Saved network management (list, forget, configure)
# - Signal strength monitoring and quality assessment
# - Access Point (AP) mode support
# - Ad-hoc network support
# - BSS (Base Station Set) management
# - Auto-connect configuration
# - Event emission for network state changes
# - Caching for expensive operations
# - Graceful degradation without optional dependencies
#
# =============================================================================

# Source guard - prevent multiple loading
[[ -n "${WIFI_LOADED:-}" ]] && return 0
declare -g WIFI_LOADED=1

# Version
declare -r WIFI_VERSION="1.0.0"

# =============================================================================
# DEPENDENCIES
# =============================================================================

# Required: _common library
if ! source "$(which _common)" 2>/dev/null; then
    echo "Error: _common library not found" >&2
    echo "The _wifi extension requires _common library" >&2
    echo "Install: cd ~/.dotfiles && stow lib" >&2
    return 1
fi

# Optional: _log library for structured logging
if source "$(which _log)" 2>/dev/null; then
    declare -g WIFI_LOG_AVAILABLE=true
else
    declare -g WIFI_LOG_AVAILABLE=false
    # Fallback logging functions
    log-debug() { [[ "${WIFI_DEBUG:-false}" == "true" ]] && echo "[DEBUG] $*" >&2; }
    log-info() { echo "[INFO] $*" >&2; }
    log-warn() { echo "[WARN] $*" >&2; }
    log-error() { echo "[ERROR] $*" >&2; }
fi

# Optional: _events library for event emission
if source "$(which _events)" 2>/dev/null; then
    declare -g WIFI_EVENTS_AVAILABLE=true
else
    declare -g WIFI_EVENTS_AVAILABLE=false
fi

# Optional: _cache library for caching scan results
if source "$(which _cache)" 2>/dev/null; then
    declare -g WIFI_CACHE_AVAILABLE=true
else
    declare -g WIFI_CACHE_AVAILABLE=false
fi

# Optional: _lifecycle library for cleanup management
if source "$(which _lifecycle)" 2>/dev/null; then
    declare -g WIFI_LIFECYCLE_AVAILABLE=true
else
    declare -g WIFI_LIFECYCLE_AVAILABLE=false
fi

# Optional: _config library for configuration management
if source "$(which _config)" 2>/dev/null; then
    declare -g WIFI_CONFIG_AVAILABLE=true
else
    declare -g WIFI_CONFIG_AVAILABLE=false
fi

# =============================================================================
# CONFIGURATION
# =============================================================================

# XDG directory paths
declare -g WIFI_CACHE_DIR="$(common-lib-cache-dir wifi)"
declare -g WIFI_STATE_DIR="$(common-lib-state-dir wifi)"
declare -g WIFI_CONFIG_DIR="$(common-lib-config-dir wifi)"

# System paths
declare -g WIFI_IWD_CONFIG_DIR="/var/lib/iwd"
declare -g WIFI_IWD_STATE_DIR="/var/lib/iwd"

# Behavior flags
declare -g WIFI_DEBUG="${WIFI_DEBUG:-false}"
declare -g WIFI_EMIT_EVENTS="${WIFI_EMIT_EVENTS:-true}"
declare -g WIFI_AUTO_SCAN="${WIFI_AUTO_SCAN:-true}"
declare -g WIFI_CACHE_SCANS="${WIFI_CACHE_SCANS:-true}"
declare -g WIFI_DRY_RUN="${WIFI_DRY_RUN:-false}"

# Default values
declare -g WIFI_DEFAULT_DEVICE="${WIFI_DEFAULT_DEVICE:-}"
declare -g WIFI_SCAN_TIMEOUT="${WIFI_SCAN_TIMEOUT:-10}"
declare -g WIFI_CONNECT_TIMEOUT="${WIFI_CONNECT_TIMEOUT:-30}"
declare -g WIFI_CACHE_TTL="${WIFI_CACHE_TTL:-30}"
declare -g WIFI_SIGNAL_FORMAT="${WIFI_SIGNAL_FORMAT:-bars}"  # bars, dbms, quality

# Signal strength thresholds (in dBm)
declare -g WIFI_SIGNAL_EXCELLENT="${WIFI_SIGNAL_EXCELLENT:--50}"
declare -g WIFI_SIGNAL_GOOD="${WIFI_SIGNAL_GOOD:--60}"
declare -g WIFI_SIGNAL_FAIR="${WIFI_SIGNAL_FAIR:--70}"
declare -g WIFI_SIGNAL_POOR="${WIFI_SIGNAL_POOR:--80}"

# Event names
declare -r WIFI_EVENT_INITIALIZED="wifi.initialized"
declare -r WIFI_EVENT_SCAN_START="wifi.scan.start"
declare -r WIFI_EVENT_SCAN_COMPLETE="wifi.scan.complete"
declare -r WIFI_EVENT_SCAN_FAILED="wifi.scan.failed"
declare -r WIFI_EVENT_CONNECT_START="wifi.connect.start"
declare -r WIFI_EVENT_CONNECT_SUCCESS="wifi.connect.success"
declare -r WIFI_EVENT_CONNECT_FAILED="wifi.connect.failed"
declare -r WIFI_EVENT_DISCONNECT="wifi.disconnect"
declare -r WIFI_EVENT_NETWORK_FOUND="wifi.network.found"
declare -r WIFI_EVENT_KNOWN_FORGOTTEN="wifi.known.forgotten"
declare -r WIFI_EVENT_AP_STARTED="wifi.ap.started"
declare -r WIFI_EVENT_AP_STOPPED="wifi.ap.stopped"
declare -r WIFI_EVENT_ERROR="wifi.error"

# =============================================================================
# INTERNAL STATE
# =============================================================================

# Track initialization
declare -g WIFI_INITIALIZED=false

# Track active connections per device
declare -gA WIFI_ACTIVE_CONNECTIONS=()

# Track monitoring processes
declare -g WIFI_MONITOR_PID=""

# Track event callbacks
declare -gA WIFI_EVENT_CALLBACKS=()

# Cache for device lists
declare -g WIFI_DEVICES_CACHE=""
declare -g WIFI_DEVICES_CACHE_TIME=0

# =============================================================================
# INTERNAL HELPER FUNCTIONS
# =============================================================================

# Function: _wifi-init-dirs
# Description: Initialize required directories
# Parameters: None
# Returns:
#   0 - Success
#   1 - Failed to create directories
_wifi-init-dirs() {
    local dirs=(
        "$WIFI_CACHE_DIR"
        "$WIFI_STATE_DIR"
        "$WIFI_CONFIG_DIR"
    )

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            if ! mkdir -p "$dir" 2>/dev/null; then
                log-error "Failed to create directory: $dir"
                return 1
            fi
        fi
    done

    return 0
}

# Function: _wifi-emit
# Description: Emit event if events system is available
# Parameters:
#   $1 - event_name (required)
#   $@ - event_data (optional, key=value pairs)
# Returns: Always 0
_wifi-emit() {
    [[ "$WIFI_EMIT_EVENTS" != "true" ]] && return 0
    [[ "$WIFI_EVENTS_AVAILABLE" != "true" ]] && return 0

    local event_name="$1"
    shift

    events-emit "$event_name" "$@"
    return 0
}

# Function: _wifi-check-daemon
# Description: Check if iwd daemon is running
# Parameters: None
# Returns:
#   0 - Daemon is running
#   1 - Daemon is not running
_wifi-check-daemon() {
    if common-command-exists systemctl; then
        systemctl is-active iwd &>/dev/null && return 0
    fi

    # Fallback: check if iwctl responds
    if timeout 2 iwctl version &>/dev/null; then
        return 0
    fi

    return 1
}

# Function: _wifi-validate-device
# Description: Validate that a device exists
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Device exists
#   1 - Device does not exist
_wifi-validate-device() {
    local device="$1"

    [[ -z "$device" ]] && return 1

    local devices
    devices=$(wifi-device-list) || return 1

    echo "$devices" | grep -q "^$device$" && return 0
    return 1
}

# Function: _wifi-get-default-device
# Description: Auto-detect the default WiFi device
# Parameters: None
# Returns:
#   0 - Success (prints device name)
#   1 - No device found
_wifi-get-default-device() {
    # Use cached default if set
    if [[ -n "$WIFI_DEFAULT_DEVICE" ]]; then
        echo "$WIFI_DEFAULT_DEVICE"
        return 0
    fi

    # Get first available device
    local device
    device=$(wifi-device-list | head -n1)

    if [[ -n "$device" ]]; then
        echo "$device"
        return 0
    fi

    return 1
}

# Function: _wifi-format-rssi
# Description: Format RSSI signal strength
# Parameters:
#   $1 - rssi (in dBm, e.g., -65)
#   $2 - format (optional: bars, dbms, quality, default: bars)
# Returns:
#   0 - Success (prints formatted value)
_wifi-format-rssi() {
    local rssi="$1"
    local format="${2:-${WIFI_SIGNAL_FORMAT}}"

    # Remove any non-numeric characters except minus
    rssi="${rssi//[^0-9-]/}"

    case "$format" in
        bars)
            wifi-signal-to-bars "$rssi"
            ;;
        dbms|dBm)
            echo "${rssi} dBm"
            ;;
        quality|percent)
            wifi-signal-to-quality "$rssi"
            ;;
        *)
            echo "$rssi"
            ;;
    esac
}

# Function: _wifi-parse-network-line
# Description: Parse a network line from iwctl output
# Parameters:
#   $1 - line (required)
# Returns:
#   0 - Success (prints JSON object)
_wifi-parse-network-line() {
    local line="$1"

    # iwctl output format:
    # Network name              Security  Signal
    # MyNetwork                 psk       ****

    # Skip header lines
    [[ "$line" =~ ^(Network|---) ]] && return 1

    # Parse fields (fields are space-separated, names can contain spaces)
    local name security signal

    # Extract signal (last field)
    signal=$(echo "$line" | awk '{print $NF}')

    # Extract security (second to last field)
    security=$(echo "$line" | awk '{print $(NF-1)}')

    # Extract name (everything except last two fields)
    name=$(echo "$line" | awk '{$NF=""; $(NF-1)=""; print $0}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    # Output JSON
    if common-command-exists jq; then
        jq -n \
            --arg name "$name" \
            --arg security "$security" \
            --arg signal "$signal" \
            '{name: $name, security: $security, signal: $signal}'
    else
        echo "{\"name\":\"$name\",\"security\":\"$security\",\"signal\":\"$signal\"}"
    fi
}

# =============================================================================
# PUBLIC API - INITIALIZATION
# =============================================================================

# Function: wifi-init
# Description: Initialize the WiFi extension
# Parameters: None
# Returns:
#   0 - Successfully initialized
#   1 - Initialization failed
# Events:
#   wifi.initialized - When initialization completes
# Example:
#   wifi-init || exit 1
wifi-init() {
    [[ "$WIFI_INITIALIZED" == "true" ]] && return 0

    log-debug "Initializing _wifi extension v${WIFI_VERSION}"

    # Create directories
    _wifi-init-dirs || {
        log-error "Failed to initialize directories"
        return 1
    }

    # Check if iwctl is available
    if ! common-command-exists iwctl; then
        log-error "iwctl command not found"
        log-info "Install iwd package: pacman -S iwd"
        return 1
    fi

    # Check if iwd daemon is running
    if ! _wifi-check-daemon; then
        log-warn "iwd daemon is not running"
        log-info "Start daemon: systemctl start iwd"
        log-info "Enable daemon: systemctl enable iwd"
        # Don't fail - user might start it manually
    fi

    WIFI_INITIALIZED=true

    log-debug "WiFi extension initialized" \
        "version=$WIFI_VERSION" \
        "log=${WIFI_LOG_AVAILABLE}" \
        "events=${WIFI_EVENTS_AVAILABLE}" \
        "cache=${WIFI_CACHE_AVAILABLE}" \
        "lifecycle=${WIFI_LIFECYCLE_AVAILABLE}"

    _wifi-emit "$WIFI_EVENT_INITIALIZED" "version=$WIFI_VERSION"

    return 0
}

# Function: wifi-check-available
# Description: Check if WiFi functionality is available
# Parameters: None
# Returns:
#   0 - WiFi is available (iwctl and iwd present)
#   1 - WiFi is not available
# Example:
#   if wifi-check-available; then
#       echo "WiFi is available"
#   fi
wifi-check-available() {
    common-command-exists iwctl || return 1
    _wifi-check-daemon || return 1
    return 0
}

# Function: wifi-require-available
# Description: Require WiFi to be available, exit if not
# Parameters: None
# Returns:
#   0 - WiFi is available
#   1 - WiFi is not available (also logs error)
# Example:
#   wifi-require-available || exit 1
wifi-require-available() {
    if ! wifi-check-available; then
        log-error "WiFi is not available"
        log-info "Ensure iwd is installed and running"
        return 1
    fi
    return 0
}

# =============================================================================
# PUBLIC API - DEVICE MANAGEMENT
# =============================================================================

# Function: wifi-device-list
# Description: List all WiFi devices
# Parameters: None
# Returns:
#   0 - Success (prints device names, one per line)
#   1 - Failed to list devices
# Example:
#   devices=$(wifi-device-list)
#   echo "$devices"
wifi-device-list() {
    wifi-require-available || return 1

    # Check cache
    if [[ "$WIFI_CACHE_AVAILABLE" == "true" ]] && [[ "$WIFI_CACHE_SCANS" == "true" ]]; then
        local now=$(date +%s)
        local age=$((now - WIFI_DEVICES_CACHE_TIME))

        if [[ $age -lt $WIFI_CACHE_TTL ]] && [[ -n "$WIFI_DEVICES_CACHE" ]]; then
            log-debug "Using cached device list" "age=${age}s"
            echo "$WIFI_DEVICES_CACHE"
            return 0
        fi
    fi

    local output
    output=$(iwctl device list 2>/dev/null) || {
        log-error "Failed to list devices"
        return 1
    }

    # Parse output (skip header, extract device names)
    local devices
    devices=$(echo "$output" | awk 'NR>3 && NF>0 {print $1}' | grep -v '^$')

    # Cache result
    WIFI_DEVICES_CACHE="$devices"
    WIFI_DEVICES_CACHE_TIME=$(date +%s)

    echo "$devices"
    return 0
}

# Function: wifi-device-show
# Description: Show detailed information about a device
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Success (prints device information)
#   1 - Failed to get device info
# Example:
#   wifi-device-show wlan0
wifi-device-show() {
    local device="$1"

    common-validate-required "device" "$device" || return 2
    wifi-require-available || return 1
    _wifi-validate-device "$device" || {
        log-error "Invalid device: $device"
        return 1
    }

    iwctl station "$device" show 2>/dev/null || {
        log-error "Failed to show device info" "device=$device"
        return 1
    }
}

# Function: wifi-device-get-default
# Description: Get the default WiFi device
# Parameters: None
# Returns:
#   0 - Success (prints device name)
#   1 - No device found
# Example:
#   device=$(wifi-device-get-default)
wifi-device-get-default() {
    _wifi-get-default-device
}

# Function: wifi-device-is-up
# Description: Check if a device is up
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Device is up
#   1 - Device is down or doesn't exist
# Example:
#   if wifi-device-is-up wlan0; then
#       echo "Device is up"
#   fi
wifi-device-is-up() {
    local device="$1"

    common-validate-required "device" "$device" || return 1
    _wifi-validate-device "$device" || return 1

    # Check if device shows as powered on
    local output
    output=$(iwctl station "$device" show 2>/dev/null) || return 1

    echo "$output" | grep -qi "powered.*on" && return 0
    return 1
}

# =============================================================================
# PUBLIC API - NETWORK SCANNING
# =============================================================================

# Function: wifi-scan
# Description: Trigger a network scan on a device
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Scan initiated successfully
#   1 - Scan failed
# Events:
#   wifi.scan.start - When scan starts
#   wifi.scan.complete - When scan completes
#   wifi.scan.failed - When scan fails
# Example:
#   wifi-scan wlan0
wifi-scan() {
    local device="$1"

    common-validate-required "device" "$device" || return 2
    wifi-require-available || return 1
    _wifi-validate-device "$device" || {
        log-error "Invalid device: $device"
        return 1
    }

    log-debug "Starting network scan" "device=$device"
    _wifi-emit "$WIFI_EVENT_SCAN_START" "device=$device"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would scan for networks" "device=$device"
        return 0
    fi

    if iwctl station "$device" scan 2>/dev/null; then
        log-debug "Scan initiated" "device=$device"

        # Wait a moment for scan to complete
        sleep 1

        _wifi-emit "$WIFI_EVENT_SCAN_COMPLETE" "device=$device"
        return 0
    else
        log-error "Failed to scan" "device=$device"
        _wifi-emit "$WIFI_EVENT_SCAN_FAILED" "device=$device"
        return 1
    fi
}

# Function: wifi-get-networks
# Description: Get list of discovered networks
# Parameters:
#   $1 - device (required)
#   $2 - format (optional: raw, bars, dbms, default: raw)
# Returns:
#   0 - Success (prints network list)
#   1 - Failed to get networks
# Example:
#   networks=$(wifi-get-networks wlan0 bars)
wifi-get-networks() {
    local device="$1"
    local format="${2:-raw}"

    common-validate-required "device" "$device" || return 2
    wifi-require-available || return 1
    _wifi-validate-device "$device" || {
        log-error "Invalid device: $device"
        return 1
    }

    local output
    output=$(iwctl station "$device" get-networks 2>/dev/null) || {
        log-error "Failed to get networks" "device=$device"
        return 1
    }

    # Return raw output or format it
    if [[ "$format" == "raw" ]]; then
        echo "$output"
    else
        # Parse and format each network line
        echo "$output" | while IFS= read -r line; do
            # Skip header and separator lines
            [[ "$line" =~ ^(Network|------) ]] && continue
            [[ -z "$line" ]] && continue

            # Parse network info
            local name security signal
            signal=$(echo "$line" | awk '{print $NF}')
            security=$(echo "$line" | awk '{print $(NF-1)}')
            name=$(echo "$line" | awk '{$NF=""; $(NF-1)=""; print $0}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            [[ -z "$name" ]] && continue

            # Format output
            if [[ "$format" == "bars" ]]; then
                printf "%-4s %-10s %s\n" "$signal" "$security" "$name"
            elif [[ "$format" == "dbms" ]]; then
                # Convert bars to approximate dBm
                local dbm
                case "$signal" in
                    ****) dbm="-50" ;;
                    \*\*\*) dbm="-60" ;;
                    \*\*) dbm="-70" ;;
                    \*) dbm="-80" ;;
                    *) dbm="-90" ;;
                esac
                printf "%-6s %-10s %s\n" "$dbm" "$security" "$name"
            else
                echo "$line"
            fi
        done
    fi
}

# Function: wifi-network-exists
# Description: Check if a network is visible
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
# Returns:
#   0 - Network exists
#   1 - Network not found
# Example:
#   if wifi-network-exists wlan0 "MyNetwork"; then
#       echo "Network found"
#   fi
wifi-network-exists() {
    local device="$1"
    local ssid="$2"

    common-validate-required "device" "$device" || return 1
    common-validate-required "ssid" "$ssid" || return 1

    local networks
    networks=$(wifi-get-networks "$device" raw) || return 1

    echo "$networks" | grep -qF "$ssid" && return 0
    return 1
}

# Function: wifi-get-signal-strength
# Description: Get signal strength for a specific network
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
#   $3 - format (optional: bars, dbms, quality, default: bars)
# Returns:
#   0 - Success (prints signal strength)
#   1 - Network not found
# Example:
#   signal=$(wifi-get-signal-strength wlan0 "MyNetwork" bars)
wifi-get-signal-strength() {
    local device="$1"
    local ssid="$2"
    local format="${3:-bars}"

    common-validate-required "device" "$device" || return 1
    common-validate-required "ssid" "$ssid" || return 1

    local networks
    networks=$(wifi-get-networks "$device" raw) || return 1

    local signal
    signal=$(echo "$networks" | grep -F "$ssid" | awk '{print $NF}')

    if [[ -z "$signal" ]]; then
        log-error "Network not found" "ssid=$ssid"
        return 1
    fi

    _wifi-format-rssi "$signal" "$format"
}

# Function: wifi-get-security-type
# Description: Get security type for a specific network
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
# Returns:
#   0 - Success (prints security type)
#   1 - Network not found
# Example:
#   security=$(wifi-get-security-type wlan0 "MyNetwork")
wifi-get-security-type() {
    local device="$1"
    local ssid="$2"

    common-validate-required "device" "$device" || return 1
    common-validate-required "ssid" "$ssid" || return 1

    local networks
    networks=$(wifi-get-networks "$device" raw) || return 1

    local security
    security=$(echo "$networks" | grep -F "$ssid" | awk '{print $(NF-1)}')

    if [[ -z "$security" ]]; then
        log-error "Network not found" "ssid=$ssid"
        return 1
    fi

    echo "$security"
}

# =============================================================================
# PUBLIC API - CONNECTION MANAGEMENT
# =============================================================================

# Function: wifi-connect
# Description: Connect to a WiFi network
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
#   $3 - passphrase (optional, required for encrypted networks)
# Returns:
#   0 - Successfully connected
#   1 - Connection failed
#   2 - Invalid arguments
# Events:
#   wifi.connect.start - When connection starts
#   wifi.connect.success - When connection succeeds
#   wifi.connect.failed - When connection fails
# Example:
#   wifi-connect wlan0 "MyNetwork" "mypassword"
wifi-connect() {
    local device="$1"
    local ssid="$2"
    local passphrase="$3"

    common-validate-required "device" "$device" || return 2
    common-validate-required "ssid" "$ssid" || return 2
    wifi-require-available || return 1
    _wifi-validate-device "$device" || {
        log-error "Invalid device: $device"
        return 1
    }

    log-info "Connecting to network" "device=$device" "ssid=$ssid"
    _wifi-emit "$WIFI_EVENT_CONNECT_START" "device=$device" "ssid=$ssid"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would connect to network" "device=$device" "ssid=$ssid"
        _wifi-emit "$WIFI_EVENT_CONNECT_SUCCESS" "device=$device" "ssid=$ssid"
        return 0
    fi

    local cmd="iwctl station \"$device\" connect \"$ssid\""

    # Add passphrase if provided
    if [[ -n "$passphrase" ]]; then
        cmd="$cmd --passphrase \"$passphrase\""
    fi

    # Execute connection command
    if eval "$cmd" 2>/dev/null; then
        log-info "Successfully connected" "device=$device" "ssid=$ssid"
        WIFI_ACTIVE_CONNECTIONS["$device"]="$ssid"
        _wifi-emit "$WIFI_EVENT_CONNECT_SUCCESS" "device=$device" "ssid=$ssid"
        return 0
    else
        log-error "Connection failed" "device=$device" "ssid=$ssid"
        _wifi-emit "$WIFI_EVENT_CONNECT_FAILED" "device=$device" "ssid=$ssid"
        return 1
    fi
}

# Function: wifi-connect-hidden
# Description: Connect to a hidden WiFi network
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
#   $3 - passphrase (optional)
# Returns:
#   0 - Successfully connected
#   1 - Connection failed
# Example:
#   wifi-connect-hidden wlan0 "HiddenNetwork" "password"
wifi-connect-hidden() {
    local device="$1"
    local ssid="$2"
    local passphrase="$3"

    common-validate-required "device" "$device" || return 2
    common-validate-required "ssid" "$ssid" || return 2
    wifi-require-available || return 1

    log-info "Connecting to hidden network" "device=$device" "ssid=$ssid"
    _wifi-emit "$WIFI_EVENT_CONNECT_START" "device=$device" "ssid=$ssid" "hidden=true"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would connect to hidden network" "device=$device" "ssid=$ssid"
        return 0
    fi

    local cmd="iwctl station \"$device\" connect-hidden \"$ssid\""

    if [[ -n "$passphrase" ]]; then
        cmd="$cmd --passphrase \"$passphrase\""
    fi

    if eval "$cmd" 2>/dev/null; then
        log-info "Successfully connected to hidden network" "device=$device" "ssid=$ssid"
        WIFI_ACTIVE_CONNECTIONS["$device"]="$ssid"
        _wifi-emit "$WIFI_EVENT_CONNECT_SUCCESS" "device=$device" "ssid=$ssid" "hidden=true"
        return 0
    else
        log-error "Failed to connect to hidden network" "device=$device" "ssid=$ssid"
        _wifi-emit "$WIFI_EVENT_CONNECT_FAILED" "device=$device" "ssid=$ssid" "hidden=true"
        return 1
    fi
}

# Function: wifi-disconnect
# Description: Disconnect from current network
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Successfully disconnected
#   1 - Disconnect failed
# Events:
#   wifi.disconnect - When disconnected
# Example:
#   wifi-disconnect wlan0
wifi-disconnect() {
    local device="$1"

    common-validate-required "device" "$device" || return 2
    wifi-require-available || return 1
    _wifi-validate-device "$device" || {
        log-error "Invalid device: $device"
        return 1
    }

    log-info "Disconnecting" "device=$device"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would disconnect" "device=$device"
        return 0
    fi

    if iwctl station "$device" disconnect 2>/dev/null; then
        log-info "Successfully disconnected" "device=$device"
        unset "WIFI_ACTIVE_CONNECTIONS[$device]"
        _wifi-emit "$WIFI_EVENT_DISCONNECT" "device=$device"
        return 0
    else
        log-error "Failed to disconnect" "device=$device"
        return 1
    fi
}

# Function: wifi-is-connected
# Description: Check if device is connected to a network
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Device is connected
#   1 - Device is not connected
# Example:
#   if wifi-is-connected wlan0; then
#       echo "Connected"
#   fi
wifi-is-connected() {
    local device="$1"

    common-validate-required "device" "$device" || return 1
    wifi-require-available || return 1

    local output
    output=$(iwctl station "$device" show 2>/dev/null) || return 1

    # Check if "State" shows "connected"
    echo "$output" | grep -qi "State.*connected" && return 0
    return 1
}

# Function: wifi-get-connected-ssid
# Description: Get the SSID of the currently connected network
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Success (prints SSID)
#   1 - Not connected or failed
# Example:
#   ssid=$(wifi-get-connected-ssid wlan0)
wifi-get-connected-ssid() {
    local device="$1"

    common-validate-required "device" "$device" || return 1
    wifi-require-available || return 1

    local output
    output=$(iwctl station "$device" show 2>/dev/null) || return 1

    # Extract "Connected network" field
    local ssid
    ssid=$(echo "$output" | grep "Connected network" | awk -F': ' '{print $2}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    if [[ -n "$ssid" ]]; then
        echo "$ssid"
        return 0
    fi

    return 1
}

# Function: wifi-get-connection-status
# Description: Get comprehensive connection status
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - Success (prints status information)
#   1 - Failed to get status
# Example:
#   wifi-get-connection-status wlan0
wifi-get-connection-status() {
    local device="$1"

    common-validate-required "device" "$device" || return 1
    wifi-require-available || return 1

    wifi-device-show "$device"
}

# =============================================================================
# PUBLIC API - SAVED NETWORKS
# =============================================================================

# Function: wifi-known-list
# Description: List all known (saved) networks
# Parameters: None
# Returns:
#   0 - Success (prints known networks)
#   1 - Failed to list networks
# Example:
#   wifi-known-list
wifi-known-list() {
    wifi-require-available || return 1

    iwctl known-networks list 2>/dev/null || {
        log-error "Failed to list known networks"
        return 1
    }
}

# Function: wifi-known-show
# Description: Show details of a known network
# Parameters:
#   $1 - ssid (required)
# Returns:
#   0 - Success (prints network details)
#   1 - Failed to show network
# Example:
#   wifi-known-show "MyNetwork"
wifi-known-show() {
    local ssid="$1"

    common-validate-required "ssid" "$ssid" || return 2
    wifi-require-available || return 1

    iwctl known-networks "$ssid" show 2>/dev/null || {
        log-error "Failed to show known network" "ssid=$ssid"
        return 1
    }
}

# Function: wifi-known-forget
# Description: Forget (remove) a saved network
# Parameters:
#   $1 - ssid (required)
# Returns:
#   0 - Successfully forgotten
#   1 - Failed to forget network
# Events:
#   wifi.known.forgotten - When network is forgotten
# Example:
#   wifi-known-forget "OldNetwork"
wifi-known-forget() {
    local ssid="$1"

    common-validate-required "ssid" "$ssid" || return 2
    wifi-require-available || return 1

    log-info "Forgetting network" "ssid=$ssid"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would forget network" "ssid=$ssid"
        return 0
    fi

    if iwctl known-networks "$ssid" forget 2>/dev/null; then
        log-info "Network forgotten" "ssid=$ssid"
        _wifi-emit "$WIFI_EVENT_KNOWN_FORGOTTEN" "ssid=$ssid"
        return 0
    else
        log-error "Failed to forget network" "ssid=$ssid"
        return 1
    fi
}

# Function: wifi-known-forget-all
# Description: Forget all saved networks
# Parameters: None
# Returns:
#   0 - All networks forgotten
#   1 - Failed to forget networks
# Example:
#   wifi-known-forget-all
wifi-known-forget-all() {
    wifi-require-available || return 1

    log-warn "Forgetting all known networks"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would forget all networks"
        return 0
    fi

    local networks
    networks=$(wifi-known-list | awk 'NR>3 && NF>0 {print $1}' | grep -v '^$')

    local failed=0
    while IFS= read -r ssid; do
        [[ -z "$ssid" ]] && continue

        if ! wifi-known-forget "$ssid"; then
            ((failed++))
        fi
    done <<< "$networks"

    if [[ $failed -eq 0 ]]; then
        log-info "All networks forgotten"
        return 0
    else
        log-error "Failed to forget some networks" "failed=$failed"
        return 1
    fi
}

# Function: wifi-known-exists
# Description: Check if a network is in known networks
# Parameters:
#   $1 - ssid (required)
# Returns:
#   0 - Network is known
#   1 - Network is not known
# Example:
#   if wifi-known-exists "MyNetwork"; then
#       echo "Network is saved"
#   fi
wifi-known-exists() {
    local ssid="$1"

    common-validate-required "ssid" "$ssid" || return 1
    wifi-require-available || return 1

    local networks
    networks=$(wifi-known-list) || return 1

    echo "$networks" | grep -qF "$ssid" && return 0
    return 1
}

# =============================================================================
# PUBLIC API - ACCESS POINT MODE
# =============================================================================

# Function: wifi-ap-start
# Description: Start access point mode
# Parameters:
#   $1 - device (required)
#   $2 - ssid (required)
#   $3 - passphrase (optional, creates open network if omitted)
# Returns:
#   0 - AP started successfully
#   1 - Failed to start AP
# Events:
#   wifi.ap.started - When AP starts
# Example:
#   wifi-ap-start wlan0 "MyAP" "password123"
wifi-ap-start() {
    local device="$1"
    local ssid="$2"
    local passphrase="$3"

    common-validate-required "device" "$device" || return 2
    common-validate-required "ssid" "$ssid" || return 2
    wifi-require-available || return 1

    log-info "Starting access point" "device=$device" "ssid=$ssid"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would start AP" "device=$device" "ssid=$ssid"
        return 0
    fi

    local cmd="iwctl ap \"$device\" start \"$ssid\""

    if [[ -n "$passphrase" ]]; then
        cmd="$cmd \"$passphrase\""
    fi

    if eval "$cmd" 2>/dev/null; then
        log-info "Access point started" "device=$device" "ssid=$ssid"
        _wifi-emit "$WIFI_EVENT_AP_STARTED" "device=$device" "ssid=$ssid"
        return 0
    else
        log-error "Failed to start access point" "device=$device" "ssid=$ssid"
        return 1
    fi
}

# Function: wifi-ap-stop
# Description: Stop access point mode
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - AP stopped successfully
#   1 - Failed to stop AP
# Events:
#   wifi.ap.stopped - When AP stops
# Example:
#   wifi-ap-stop wlan0
wifi-ap-stop() {
    local device="$1"

    common-validate-required "device" "$device" || return 2
    wifi-require-available || return 1

    log-info "Stopping access point" "device=$device"

    if [[ "$WIFI_DRY_RUN" == "true" ]]; then
        log-info "[DRY RUN] Would stop AP" "device=$device"
        return 0
    fi

    if iwctl ap "$device" stop 2>/dev/null; then
        log-info "Access point stopped" "device=$device"
        _wifi-emit "$WIFI_EVENT_AP_STOPPED" "device=$device"
        return 0
    else
        log-error "Failed to stop access point" "device=$device"
        return 1
    fi
}

# Function: wifi-ap-is-active
# Description: Check if access point is active
# Parameters:
#   $1 - device (required)
# Returns:
#   0 - AP is active
#   1 - AP is not active
# Example:
#   if wifi-ap-is-active wlan0; then
#       echo "AP is running"
#   fi
wifi-ap-is-active() {
    local device="$1"

    common-validate-required "device" "$device" || return 1
    wifi-require-available || return 1

    local output
    output=$(iwctl ap "$device" show 2>/dev/null) || return 1

    echo "$output" | grep -qi "Started.*yes" && return 0
    return 1
}

# =============================================================================
# PUBLIC API - UTILITY FUNCTIONS
# =============================================================================

# Function: wifi-signal-to-bars
# Description: Convert RSSI (dBm) to signal bars
# Parameters:
#   $1 - rssi (required, in dBm)
# Returns:
#   0 - Success (prints bars: ****, ***, **, *, -)
# Example:
#   bars=$(wifi-signal-to-bars -65)
wifi-signal-to-bars() {
    local rssi="${1//[^0-9-]/}"

    if [[ $rssi -ge $WIFI_SIGNAL_EXCELLENT ]]; then
        echo "****"
    elif [[ $rssi -ge $WIFI_SIGNAL_GOOD ]]; then
        echo "***"
    elif [[ $rssi -ge $WIFI_SIGNAL_FAIR ]]; then
        echo "**"
    elif [[ $rssi -ge $WIFI_SIGNAL_POOR ]]; then
        echo "*"
    else
        echo "-"
    fi
}

# Function: wifi-signal-to-quality
# Description: Convert RSSI (dBm) to quality percentage
# Parameters:
#   $1 - rssi (required, in dBm)
# Returns:
#   0 - Success (prints percentage: 0-100%)
# Example:
#   quality=$(wifi-signal-to-quality -65)
wifi-signal-to-quality() {
    local rssi="${1//[^0-9-]/}"

    # Convert dBm to quality percentage
    # Formula: quality = 2 * (dBm + 100)
    # Range: -100 dBm (0%) to -50 dBm (100%)

    local quality=$(( 2 * (rssi + 100) ))

    # Clamp to 0-100
    [[ $quality -lt 0 ]] && quality=0
    [[ $quality -gt 100 ]] && quality=100

    echo "${quality}%"
}

# Function: wifi-cleanup
# Description: Cleanup resources and stop monitoring
# Parameters: None
# Returns: 0
# Example:
#   wifi-cleanup
wifi-cleanup() {
    log-debug "Cleaning up WiFi extension"

    # Stop monitoring if running
    if [[ -n "$WIFI_MONITOR_PID" ]] && kill -0 "$WIFI_MONITOR_PID" 2>/dev/null; then
        kill "$WIFI_MONITOR_PID" 2>/dev/null
        WIFI_MONITOR_PID=""
    fi

    # Clear state
    WIFI_ACTIVE_CONNECTIONS=()
    WIFI_EVENT_CALLBACKS=()

    log-debug "WiFi cleanup complete"
    return 0
}

# Function: wifi-version
# Description: Print extension version
# Parameters: None
# Returns: 0
# Example:
#   wifi-version
wifi-version() {
    echo "$WIFI_VERSION"
}

# Function: wifi-help
# Description: Display help information
# Parameters: None
# Returns: 0
# Example:
#   wifi-help
wifi-help() {
    cat <<EOF
_wifi - WiFi/Wireless Network Management Library v${WIFI_VERSION}

DESCRIPTION:
    Comprehensive WiFi management through iwd (iNet Wireless Daemon).
    Supports device management, network scanning, connection management,
    access point mode, and signal monitoring.

DEPENDENCIES:
    Required: _common, iwctl, iwd daemon
    Optional: _log, _events, _cache, _lifecycle, _config

INTEGRATION STATUS:
    Logging:    ${WIFI_LOG_AVAILABLE}
    Events:     ${WIFI_EVENTS_AVAILABLE}
    Caching:    ${WIFI_CACHE_AVAILABLE}
    Lifecycle:  ${WIFI_LIFECYCLE_AVAILABLE}
    Config:     ${WIFI_CONFIG_AVAILABLE}

INITIALIZATION:
    wifi-init                           Initialize extension
    wifi-check-available                Check if WiFi is available
    wifi-require-available              Require WiFi (exit if not)

DEVICE MANAGEMENT:
    wifi-device-list                    List all WiFi devices
    wifi-device-show <device>           Show device details
    wifi-device-get-default             Get default device
    wifi-device-is-up <device>          Check if device is up

NETWORK SCANNING:
    wifi-scan <device>                  Scan for networks
    wifi-get-networks <device> [fmt]    Get discovered networks
    wifi-network-exists <dev> <ssid>    Check if network visible
    wifi-get-signal-strength <dev> <ssid> [fmt]  Get signal strength
    wifi-get-security-type <dev> <ssid> Get security type

CONNECTION MANAGEMENT:
    wifi-connect <dev> <ssid> [pass]    Connect to network
    wifi-connect-hidden <dev> <ssid> [pass]  Connect to hidden network
    wifi-disconnect <device>            Disconnect from network
    wifi-is-connected <device>          Check connection status
    wifi-get-connected-ssid <device>    Get current SSID
    wifi-get-connection-status <device> Get full connection status

SAVED NETWORKS:
    wifi-known-list                     List saved networks
    wifi-known-show <ssid>              Show saved network details
    wifi-known-forget <ssid>            Remove saved network
    wifi-known-forget-all               Remove all saved networks
    wifi-known-exists <ssid>            Check if network is saved

ACCESS POINT MODE:
    wifi-ap-start <dev> <ssid> [pass]   Start access point
    wifi-ap-stop <device>               Stop access point
    wifi-ap-is-active <device>          Check if AP is running

UTILITY FUNCTIONS:
    wifi-signal-to-bars <rssi>          Convert dBm to bars
    wifi-signal-to-quality <rssi>       Convert dBm to percentage
    wifi-cleanup                        Cleanup resources
    wifi-version                        Show version
    wifi-help                           Show this help

CONFIGURATION:
    WIFI_DEBUG                          Enable debug logging
    WIFI_AUTO_SCAN                      Auto-scan on init
    WIFI_CACHE_SCANS                    Cache scan results
    WIFI_CACHE_TTL                      Cache TTL in seconds
    WIFI_SIGNAL_FORMAT                  Default format (bars/dbms/quality)
    WIFI_DRY_RUN                        Dry-run mode

EVENTS:
    wifi.initialized                    Extension initialized
    wifi.scan.start                     Scan started
    wifi.scan.complete                  Scan completed
    wifi.connect.start                  Connection started
    wifi.connect.success                Connected successfully
    wifi.connect.failed                 Connection failed
    wifi.disconnect                     Disconnected
    wifi.known.forgotten                Network forgotten
    wifi.ap.started                     AP started
    wifi.ap.stopped                     AP stopped

EXAMPLES:
    # Initialize
    source "\$(which _wifi)"
    wifi-init || exit 1

    # Scan and connect
    device=\$(wifi-device-get-default)
    wifi-scan "\$device"
    networks=\$(wifi-get-networks "\$device" bars)
    wifi-connect "\$device" "MyNetwork" "password"

    # Check status
    if wifi-is-connected "\$device"; then
        ssid=\$(wifi-get-connected-ssid "\$device")
        echo "Connected to: \$ssid"
    fi

AUTHOR:
    andronics

SEE ALSO:
    _common(3), _log(3), _events(3), _lifecycle(3)
    iwctl(1), iwd(8)
EOF
}

# Function: wifi-self-test
# Description: Run self-tests to validate functionality
# Parameters: None
# Returns:
#   0 - All tests passed
#   1 - Some tests failed
# Example:
#   wifi-self-test
wifi-self-test() {
    local tests_run=0
    local tests_passed=0
    local tests_failed=0

    echo "Running WiFi extension self-tests..."
    echo

    # Test: Check if iwctl is available
    ((tests_run++))
    if common-command-exists iwctl; then
        echo "✓ iwctl command is available"
        ((tests_passed++))
    else
        echo "✗ iwctl command not found"
        ((tests_failed++))
    fi

    # Test: Check if iwd daemon is running
    ((tests_run++))
    if _wifi-check-daemon; then
        echo "✓ iwd daemon is running"
        ((tests_passed++))
    else
        echo "✗ iwd daemon is not running"
        ((tests_failed++))
    fi

    # Test: List devices
    ((tests_run++))
    local devices
    devices=$(wifi-device-list 2>/dev/null)
    if [[ $? -eq 0 ]]; then
        echo "✓ Can list WiFi devices"
        ((tests_passed++))
        if [[ -n "$devices" ]]; then
            echo "  Found devices: $devices"
        fi
    else
        echo "✗ Failed to list devices"
        ((tests_failed++))
    fi

    # Test: Signal conversion functions
    ((tests_run++))
    local bars
    bars=$(wifi-signal-to-bars -65)
    if [[ "$bars" == "**" ]]; then
        echo "✓ Signal to bars conversion works"
        ((tests_passed++))
    else
        echo "✗ Signal to bars conversion failed (got: $bars)"
        ((tests_failed++))
    fi

    ((tests_run++))
    local quality
    quality=$(wifi-signal-to-quality -65)
    if [[ "$quality" == "70%" ]]; then
        echo "✓ Signal to quality conversion works"
        ((tests_passed++))
    else
        echo "✗ Signal to quality conversion failed (got: $quality)"
        ((tests_failed++))
    fi

    # Test: Directory initialization
    ((tests_run++))
    if [[ -d "$WIFI_CACHE_DIR" ]] && [[ -d "$WIFI_STATE_DIR" ]] && [[ -d "$WIFI_CONFIG_DIR" ]]; then
        echo "✓ All directories exist"
        ((tests_passed++))
    else
        echo "✗ Some directories missing"
        ((tests_failed++))
    fi

    echo
    echo "Tests run: $tests_run"
    echo "Passed: $tests_passed"
    echo "Failed: $tests_failed"

    if [[ $tests_failed -eq 0 ]]; then
        echo
        echo "All tests passed!"
        return 0
    else
        echo
        echo "Some tests failed!"
        return 1
    fi
}

# Function: wifi-info
# Description: Display system and extension information
# Parameters: None
# Returns: 0
# Example:
#   wifi-info
wifi-info() {
    cat <<EOF
WiFi Extension Information
==========================

Version:        $WIFI_VERSION
Initialized:    $WIFI_INITIALIZED

System Information:
-------------------
iwctl:          $(common-command-exists iwctl && echo "available" || echo "not found")
iwd daemon:     $(_wifi-check-daemon && echo "running" || echo "not running")
jq:             $(common-command-exists jq && echo "available" || echo "not found")

Integration Status:
-------------------
Logging:        $WIFI_LOG_AVAILABLE
Events:         $WIFI_EVENTS_AVAILABLE
Caching:        $WIFI_CACHE_AVAILABLE
Lifecycle:      $WIFI_LIFECYCLE_AVAILABLE
Config:         $WIFI_CONFIG_AVAILABLE

Configuration:
--------------
Debug:          $WIFI_DEBUG
Auto scan:      $WIFI_AUTO_SCAN
Cache scans:    $WIFI_CACHE_SCANS
Cache TTL:      $WIFI_CACHE_TTL seconds
Signal format:  $WIFI_SIGNAL_FORMAT
Dry run:        $WIFI_DRY_RUN

Directories:
------------
Cache:          $WIFI_CACHE_DIR
State:          $WIFI_STATE_DIR
Config:         $WIFI_CONFIG_DIR

Signal Thresholds:
------------------
Excellent:      $WIFI_SIGNAL_EXCELLENT dBm
Good:           $WIFI_SIGNAL_GOOD dBm
Fair:           $WIFI_SIGNAL_FAIR dBm
Poor:           $WIFI_SIGNAL_POOR dBm

Active Devices:
---------------
$(wifi-device-list 2>/dev/null || echo "None or unable to query")

Monitoring:
-----------
Monitor PID:    ${WIFI_MONITOR_PID:-Not running}

Event Callbacks:
----------------
Registered:     ${#WIFI_EVENT_CALLBACKS[@]}
EOF
}

# =============================================================================
# MODULE INITIALIZATION
# =============================================================================

# Initialize directories on load
_wifi-init-dirs

# Register cleanup with lifecycle if available
if [[ "$WIFI_LIFECYCLE_AVAILABLE" == "true" ]]; then
    lifecycle-cleanup wifi-cleanup
fi

# Log module load
log-debug "Loaded _wifi extension" \
    "version=$WIFI_VERSION" \
    "log=$WIFI_LOG_AVAILABLE" \
    "events=$WIFI_EVENTS_AVAILABLE" \
    "cache=$WIFI_CACHE_AVAILABLE" \
    "lifecycle=$WIFI_LIFECYCLE_AVAILABLE"

# Return success
return 0
