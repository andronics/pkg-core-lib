#!/usr/bin/env zsh

# _async - Asynchronous Control Flow and Parallel Execution Library
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Inspired by the JavaScript async library (https://caolan.github.io/async/v3/)
# Adapted for ZSH shell scripting with job control and background processes.
#
# Usage:
#   source "$(which _async)"
#
# Provides:
#   - Parallel execution with concurrency control
#   - Series (sequential) execution
#   - Collection operations (map, filter, each) with parallel/series/limit variants
#   - Control flow (waterfall, queue, retry, timeout)
#   - Background job management and result collection
#   - Error-first callback pattern adapted for shells
#   - Semaphore-based concurrency limiting
#   - Async memoization and caching
#
# Dependencies:
#   Required:
#     - _common v2.0: Core utilities
#   Optional (gracefully degraded):
#     - _log v2.0: Structured logging
#     - _events v2.0: Event system integration
#     - _lifecycle v3.0: Process cleanup and tracking
#     - _cache v2.0: Memoization cache backend
#

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${ASYNC_LOADED:-}" ]] && return 0
declare -g ASYNC_LOADED=1

# ------------------------------
# Version
# ------------------------------

declare -r ASYNC_VERSION="1.0.0"

# ------------------------------
# Dependency Loading
# ------------------------------

# Load foundation (required)
if ! source "$(which _common)" 2>/dev/null; then
    echo "[ERROR] _async requires _common v2.0 - cannot load" >&2
    return 1
fi

# Load infrastructure (optional with fallbacks)
if ! source "$(which _log)" 2>/dev/null; then
    # Fallback logging functions
    log-info() { echo "[INFO] $*"; }
    log-error() { echo "[ERROR] $*" >&2; }
    log-warn() { echo "[WARN] $*" >&2; }
    log-warning() { echo "[WARN] $*" >&2; }
    log-debug() { [[ "${ASYNC_DEBUG:-false}" == "true" ]] && echo "[DEBUG] $*" >&2 || true; }
    log-trace() { [[ "${ASYNC_TRACE:-false}" == "true" ]] && echo "[TRACE] $*" >&2 || true; }
    log-success() { echo "[SUCCESS] $*"; }
fi

# Check for optional extensions
if source "$(which _events)" 2>/dev/null; then
    declare -g ASYNC_EVENTS_AVAILABLE=true
else
    declare -g ASYNC_EVENTS_AVAILABLE=false
fi

if source "$(which _lifecycle)" 2>/dev/null; then
    declare -g ASYNC_LIFECYCLE_AVAILABLE=true
else
    declare -g ASYNC_LIFECYCLE_AVAILABLE=false
fi

if source "$(which _cache)" 2>/dev/null; then
    declare -g ASYNC_CACHE_AVAILABLE=true
else
    declare -g ASYNC_CACHE_AVAILABLE=false
fi

# ------------------------------
# Configuration
# ------------------------------

# XDG paths
declare -g ASYNC_CONFIG_DIR="$(common-lib-config-dir)/async"
declare -g ASYNC_CACHE_DIR="$(common-lib-cache-dir)/async"
declare -g ASYNC_STATE_DIR="$(common-lib-state-dir)/async"
declare -g ASYNC_DATA_DIR="$(common-lib-data-dir)/async"

# Behavior configuration
declare -g ASYNC_DEBUG="${ASYNC_DEBUG:-false}"
declare -g ASYNC_VERBOSE="${ASYNC_VERBOSE:-false}"
declare -g ASYNC_DRY_RUN="${ASYNC_DRY_RUN:-false}"
declare -g ASYNC_EMIT_EVENTS="${ASYNC_EMIT_EVENTS:-true}"

# Performance configuration
declare -g ASYNC_DEFAULT_CONCURRENCY="${ASYNC_DEFAULT_CONCURRENCY:-5}"
declare -g ASYNC_DEFAULT_TIMEOUT="${ASYNC_DEFAULT_TIMEOUT:-30}"
declare -g ASYNC_RETRY_DEFAULT_TIMES="${ASYNC_RETRY_DEFAULT_TIMES:-3}"
declare -g ASYNC_RETRY_DEFAULT_INTERVAL="${ASYNC_RETRY_DEFAULT_INTERVAL:-1}"
declare -g ASYNC_RETRY_BACKOFF_FACTOR="${ASYNC_RETRY_BACKOFF_FACTOR:-2}"
declare -g ASYNC_POLL_INTERVAL="${ASYNC_POLL_INTERVAL:-0.1}"

# Cleanup configuration
declare -g ASYNC_AUTO_CLEANUP="${ASYNC_AUTO_CLEANUP:-true}"

# Event names
declare -r ASYNC_EVENT_JOB_START="async.job.start"
declare -r ASYNC_EVENT_JOB_COMPLETE="async.job.complete"
declare -r ASYNC_EVENT_JOB_ERROR="async.job.error"
declare -r ASYNC_EVENT_QUEUE_DRAIN="async.queue.drain"
declare -r ASYNC_EVENT_RETRY="async.retry"

# ------------------------------
# Internal State
# ------------------------------

# Job tracking
declare -g -a _ASYNC_ACTIVE_JOBS=()
declare -g -A _ASYNC_JOB_RESULTS=()
declare -g -A _ASYNC_JOB_ERRORS=()
declare -g -A _ASYNC_JOB_STATUS=()  # pid -> running|completed|failed

# Semaphore for concurrency control
declare -g -A _ASYNC_SEMAPHORES=()  # name -> current_count

# Queue management
declare -g -A _ASYNC_QUEUES=()  # queue_name -> worker_count
declare -g -A _ASYNC_QUEUE_TASKS=()  # queue_name -> task_count

# Memoization cache
declare -g -A _ASYNC_MEMO_CACHE=()  # function_key -> result

# Temporary files for result collection
declare -g -a _ASYNC_TEMP_FILES=()

# ------------------------------
# Internal Helpers
# ------------------------------

# Initialize directories
_async-init() {
    mkdir -p "$ASYNC_CONFIG_DIR" 2>/dev/null || true
    mkdir -p "$ASYNC_CACHE_DIR" 2>/dev/null || true
    mkdir -p "$ASYNC_STATE_DIR" 2>/dev/null || true
    mkdir -p "$ASYNC_DATA_DIR" 2>/dev/null || true
}

# Emit an event (uses _events if available)
_async-emit() {
    [[ "$ASYNC_EMIT_EVENTS" != "true" ]] && return 0
    [[ "$ASYNC_EVENTS_AVAILABLE" != "true" ]] && return 0

    events-emit "$@"
}

# Create a temporary file for result collection
_async-mktemp() {
    local tmpfile
    tmpfile=$(mktemp "${TMPDIR:-/tmp}/async.XXXXXXXXXX")
    _ASYNC_TEMP_FILES+=("$tmpfile")
    echo "$tmpfile"
}

# Cleanup temporary files
_async-cleanup-temps() {
    local file
    for file in "${_ASYNC_TEMP_FILES[@]}"; do
        [[ -f "$file" ]] && rm -f "$file" 2>/dev/null || true
    done
    _ASYNC_TEMP_FILES=()
}

# Track a job
_async-track-job() {
    local pid="$1"
    _ASYNC_ACTIVE_JOBS+=("$pid")
    _ASYNC_JOB_STATUS[$pid]="running"

    # Track with lifecycle if available
    if [[ "$ASYNC_LIFECYCLE_AVAILABLE" == "true" ]]; then
        lifecycle-track-job "$pid" 2>/dev/null || true
    fi
}

# Untrack a job
_async-untrack-job() {
    local pid="$1"
    _ASYNC_ACTIVE_JOBS=("${(@)_ASYNC_ACTIVE_JOBS:#$pid}")

    if [[ "$ASYNC_LIFECYCLE_AVAILABLE" == "true" ]]; then
        lifecycle-untrack-job "$pid" 2>/dev/null || true
    fi
}

# Wait for a job and collect result
_async-wait-job() {
    local pid="$1"
    local result_file="$2"
    local exit_code=0

    # Wait for the background job
    wait "$pid" 2>/dev/null || exit_code=$?

    # Update status
    if [[ $exit_code -eq 0 ]]; then
        _ASYNC_JOB_STATUS[$pid]="completed"
        if [[ -f "$result_file" ]]; then
            _ASYNC_JOB_RESULTS[$pid]="$(<"$result_file")"
        fi
    else
        _ASYNC_JOB_STATUS[$pid]="failed"
        _ASYNC_JOB_ERRORS[$pid]=$exit_code
    fi

    _async-untrack-job "$pid"
    return $exit_code
}

# Acquire semaphore slot
_async-semaphore-acquire() {
    local sem_name="$1"
    local max_count="${2:-$ASYNC_DEFAULT_CONCURRENCY}"

    # Initialize semaphore if needed
    if [[ -z "${_ASYNC_SEMAPHORES[$sem_name]}" ]]; then
        _ASYNC_SEMAPHORES[$sem_name]=0
    fi

    # Wait until we can acquire
    while [[ ${_ASYNC_SEMAPHORES[$sem_name]} -ge $max_count ]]; do
        sleep "$ASYNC_POLL_INTERVAL"
    done

    # Increment counter
    (( _ASYNC_SEMAPHORES[$sem_name]++ ))
}

# Release semaphore slot
_async-semaphore-release() {
    local sem_name="$1"

    if [[ -n "${_ASYNC_SEMAPHORES[$sem_name]}" ]]; then
        (( _ASYNC_SEMAPHORES[$sem_name]-- ))
        [[ ${_ASYNC_SEMAPHORES[$sem_name]} -lt 0 ]] && _ASYNC_SEMAPHORES[$sem_name]=0
    fi
}

# ------------------------------
# Core Async Primitives
# ------------------------------

# Execute tasks in parallel with optional concurrency limit
#
# Function: async-parallel
# Description: Run multiple tasks in parallel and wait for all to complete
# Parameters:
#   $@ - Task functions or commands to execute in parallel
# Options:
#   --limit N - Limit concurrency to N tasks (default: unlimited)
#   --timeout N - Timeout in seconds (default: 30)
# Returns:
#   0 - All tasks completed successfully
#   1 - One or more tasks failed
# Output: Combined results from all tasks
# Example:
#   async-parallel task1 task2 task3
#   async-parallel --limit 2 task1 task2 task3 task4
#
async-parallel() {
    local limit=""
    local timeout="$ASYNC_DEFAULT_TIMEOUT"
    local -a tasks=()

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --limit)
                limit="$2"
                shift 2
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            *)
                tasks+=("$1")
                shift
                ;;
        esac
    done

    [[ ${#tasks[@]} -eq 0 ]] && return 0

    local -a pids=()
    local -a result_files=()
    local sem_name="async-parallel-$$"
    local had_errors=false

    log-debug "Starting parallel execution of ${#tasks[@]} tasks" \
        "limit=${limit:-unlimited}" "timeout=$timeout"

    # Launch all tasks
    for task in "${tasks[@]}"; do
        # Acquire semaphore if limit specified
        [[ -n "$limit" ]] && _async-semaphore-acquire "$sem_name" "$limit"

        local result_file=$(_async-mktemp)
        result_files+=("$result_file")

        # Execute task in background
        (
            local result
            if result=$(eval "$task" 2>&1); then
                echo "$result" > "$result_file"
                exit 0
            else
                echo "$result" > "$result_file"
                exit 1
            fi
        ) &

        local pid=$!
        pids+=("$pid")
        _async-track-job "$pid"
        _async-emit "$ASYNC_EVENT_JOB_START" "pid=$pid" "task=$task"

        log-trace "Launched task" "pid=$pid" "task=$task"
    done

    # Wait for all tasks with timeout
    local start_time=$SECONDS
    for i in {1..${#pids[@]}}; do
        local pid="${pids[$i]}"
        local result_file="${result_files[$i]}"
        local task="${tasks[$i]}"

        # Check timeout
        if [[ -n "$timeout" && $((SECONDS - start_time)) -ge $timeout ]]; then
            log-error "Timeout exceeded waiting for tasks"
            kill "${pids[@]}" 2>/dev/null || true
            had_errors=true
            break
        fi

        # Wait for job
        if _async-wait-job "$pid" "$result_file"; then
            _async-emit "$ASYNC_EVENT_JOB_COMPLETE" "pid=$pid" "task=$task"
            log-trace "Task completed" "pid=$pid" "task=$task"
        else
            _async-emit "$ASYNC_EVENT_JOB_ERROR" "pid=$pid" "task=$task" "exit_code=${_ASYNC_JOB_ERRORS[$pid]}"
            log-error "Task failed" "pid=$pid" "task=$task" "exit_code=${_ASYNC_JOB_ERRORS[$pid]}"
            had_errors=true
        fi

        # Release semaphore if limit specified
        [[ -n "$limit" ]] && _async-semaphore-release "$sem_name"

        # Output result
        if [[ -n "${_ASYNC_JOB_RESULTS[$pid]}" ]]; then
            echo "${_ASYNC_JOB_RESULTS[$pid]}"
        fi
    done

    # Cleanup
    [[ -n "${_ASYNC_SEMAPHORES[$sem_name]}" ]] && unset "_ASYNC_SEMAPHORES[$sem_name]"

    if [[ "$had_errors" == "true" ]]; then
        return 1
    fi

    return 0
}

# Execute tasks in series (sequential order)
#
# Function: async-series
# Description: Run tasks one after another in sequential order
# Parameters:
#   $@ - Task functions or commands to execute sequentially
# Options:
#   --stop-on-error - Stop execution on first error (default: continue)
#   --timeout N - Timeout per task in seconds
# Returns:
#   0 - All tasks completed successfully
#   1 - One or more tasks failed
# Output: Combined results from all tasks
# Example:
#   async-series task1 task2 task3
#   async-series --stop-on-error task1 task2 task3
#
async-series() {
    local stop_on_error=false
    local timeout=""
    local -a tasks=()

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --stop-on-error)
                stop_on_error=true
                shift
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            *)
                tasks+=("$1")
                shift
                ;;
        esac
    done

    [[ ${#tasks[@]} -eq 0 ]] && return 0

    local had_errors=false

    log-debug "Starting series execution of ${#tasks[@]} tasks" \
        "stop_on_error=$stop_on_error" "timeout=${timeout:-none}"

    # Execute each task sequentially
    for task in "${tasks[@]}"; do
        local result
        local exit_code=0

        log-trace "Executing task" "task=$task"
        _async-emit "$ASYNC_EVENT_JOB_START" "task=$task"

        # Execute with optional timeout
        if [[ -n "$timeout" ]]; then
            if result=$(timeout "$timeout" bash -c "$task" 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        else
            if result=$(eval "$task" 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        fi

        # Handle result
        if [[ $exit_code -eq 0 ]]; then
            _async-emit "$ASYNC_EVENT_JOB_COMPLETE" "task=$task"
            log-trace "Task completed" "task=$task"
            echo "$result"
        else
            _async-emit "$ASYNC_EVENT_JOB_ERROR" "task=$task" "exit_code=$exit_code"
            log-error "Task failed" "task=$task" "exit_code=$exit_code"
            echo "$result"
            had_errors=true

            if [[ "$stop_on_error" == "true" ]]; then
                log-warn "Stopping series execution due to error"
                return 1
            fi
        fi
    done

    if [[ "$had_errors" == "true" ]]; then
        return 1
    fi

    return 0
}

# Execute tasks in waterfall (passing output to next)
#
# Function: async-waterfall
# Description: Run tasks sequentially, passing each result to the next task
# Parameters:
#   $@ - Task functions that accept input from previous task
# Returns:
#   0 - All tasks completed successfully
#   1 - A task failed
# Output: Result of final task
# Example:
#   async-waterfall "echo start" "sed 's/start/middle/'" "sed 's/middle/end/'"
#
async-waterfall() {
    local -a tasks=("$@")

    [[ ${#tasks[@]} -eq 0 ]] && return 0

    log-debug "Starting waterfall execution of ${#tasks[@]} tasks"

    local result=""
    local exit_code=0

    for task in "${tasks[@]}"; do
        log-trace "Executing waterfall task" "task=$task"
        _async-emit "$ASYNC_EVENT_JOB_START" "task=$task"

        if [[ -n "$result" ]]; then
            # Pass previous result as input
            if result=$(echo "$result" | eval "$task" 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        else
            # First task, no input
            if result=$(eval "$task" 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        fi

        if [[ $exit_code -ne 0 ]]; then
            _async-emit "$ASYNC_EVENT_JOB_ERROR" "task=$task" "exit_code=$exit_code"
            log-error "Waterfall task failed" "task=$task" "exit_code=$exit_code"
            return 1
        fi

        _async-emit "$ASYNC_EVENT_JOB_COMPLETE" "task=$task"
        log-trace "Waterfall task completed" "task=$task"
    done

    echo "$result"
    return 0
}

# ------------------------------
# Collection Operations
# ------------------------------

# Iterate over collection in parallel
#
# Function: async-each
# Description: Execute a function for each item in a collection in parallel
# Parameters:
#   $1 - Function to execute for each item
#   $@ - Collection items
# Options:
#   --limit N - Limit concurrency (async-each-limit behavior)
#   --series - Execute sequentially (async-each-series behavior)
# Returns:
#   0 - All iterations completed successfully
#   1 - One or more iterations failed
# Example:
#   async-each "echo" item1 item2 item3
#   async-each --limit 2 "process_item" "${items[@]}"
#
async-each() {
    local limit=""
    local series=false
    local func=""
    local -a items=()

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --limit)
                limit="$2"
                shift 2
                ;;
            --series)
                series=true
                shift
                ;;
            *)
                if [[ -z "$func" ]]; then
                    func="$1"
                else
                    items+=("$1")
                fi
                shift
                ;;
        esac
    done

    common-validate-required "$func" "function" || return 2
    [[ ${#items[@]} -eq 0 ]] && return 0

    log-debug "Each: processing ${#items[@]} items" "func=$func" \
        "limit=${limit:-unlimited}" "series=$series"

    # Build task list
    local -a tasks=()
    for item in "${items[@]}"; do
        tasks+=("$func '$item'")
    done

    # Execute based on mode
    if [[ "$series" == "true" ]]; then
        async-series "${tasks[@]}" >/dev/null
    elif [[ -n "$limit" ]]; then
        async-parallel --limit "$limit" "${tasks[@]}" >/dev/null
    else
        async-parallel "${tasks[@]}" >/dev/null
    fi
}

# Map collection items in parallel
#
# Function: async-map
# Description: Transform each item using a function, collect results
# Parameters:
#   $1 - Function to execute for each item
#   $@ - Collection items
# Options:
#   --limit N - Limit concurrency
#   --series - Execute sequentially
# Returns:
#   0 - All transformations completed successfully
#   1 - One or more transformations failed
# Output: Transformed items, one per line
# Example:
#   results=$(async-map "transform_func" item1 item2 item3)
#
async-map() {
    local limit=""
    local series=false
    local func=""
    local -a items=()

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --limit)
                limit="$2"
                shift 2
                ;;
            --series)
                series=true
                shift
                ;;
            *)
                if [[ -z "$func" ]]; then
                    func="$1"
                else
                    items+=("$1")
                fi
                shift
                ;;
        esac
    done

    common-validate-required "$func" "function" || return 2
    [[ ${#items[@]} -eq 0 ]] && return 0

    log-debug "Map: processing ${#items[@]} items" "func=$func" \
        "limit=${limit:-unlimited}" "series=$series"

    # Build task list
    local -a tasks=()
    for item in "${items[@]}"; do
        tasks+=("$func '$item'")
    done

    # Execute and collect results
    if [[ "$series" == "true" ]]; then
        async-series "${tasks[@]}"
    elif [[ -n "$limit" ]]; then
        async-parallel --limit "$limit" "${tasks[@]}"
    else
        async-parallel "${tasks[@]}"
    fi
}

# Filter collection items in parallel
#
# Function: async-filter
# Description: Filter collection using a predicate function
# Parameters:
#   $1 - Predicate function (returns 0 for keep, 1 for discard)
#   $@ - Collection items
# Options:
#   --limit N - Limit concurrency
#   --series - Execute sequentially
# Returns:
#   0 - Filtering completed successfully
# Output: Items that passed the filter, one per line
# Example:
#   filtered=$(async-filter "is_valid" "${items[@]}")
#
async-filter() {
    local limit=""
    local series=false
    local predicate=""
    local -a items=()

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --limit)
                limit="$2"
                shift 2
                ;;
            --series)
                series=true
                shift
                ;;
            *)
                if [[ -z "$predicate" ]]; then
                    predicate="$1"
                else
                    items+=("$1")
                fi
                shift
                ;;
        esac
    done

    common-validate-required "$predicate" "predicate" || return 2
    [[ ${#items[@]} -eq 0 ]] && return 0

    log-debug "Filter: processing ${#items[@]} items" "predicate=$predicate" \
        "limit=${limit:-unlimited}" "series=$series"

    # Build task list that outputs item only if predicate succeeds
    local -a tasks=()
    for item in "${items[@]}"; do
        tasks+=("$predicate '$item' && echo '$item' || true")
    done

    # Execute and collect results
    if [[ "$series" == "true" ]]; then
        async-series "${tasks[@]}"
    elif [[ -n "$limit" ]]; then
        async-parallel --limit "$limit" "${tasks[@]}"
    else
        async-parallel "${tasks[@]}"
    fi
}

# ------------------------------
# Retry and Timeout Utilities
# ------------------------------

# Retry a task with exponential backoff
#
# Function: async-retry
# Description: Retry a task until it succeeds or max attempts reached
# Parameters:
#   $1 - Task function or command to retry
# Options:
#   --times N - Maximum retry attempts (default: 3)
#   --interval N - Initial retry interval in seconds (default: 1)
#   --backoff N - Backoff multiplier (default: 2)
# Returns:
#   0 - Task succeeded
#   1 - Task failed after all retries
# Output: Result of successful execution
# Example:
#   async-retry "flaky_command"
#   async-retry --times 5 --interval 2 "curl https://example.com"
#
async-retry() {
    local task=""
    local times="$ASYNC_RETRY_DEFAULT_TIMES"
    local interval="$ASYNC_RETRY_DEFAULT_INTERVAL"
    local backoff="$ASYNC_RETRY_BACKOFF_FACTOR"

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --times)
                times="$2"
                shift 2
                ;;
            --interval)
                interval="$2"
                shift 2
                ;;
            --backoff)
                backoff="$2"
                shift 2
                ;;
            *)
                task="$1"
                shift
                ;;
        esac
    done

    common-validate-required "$task" "task" || return 2

    log-debug "Retry: starting" "task=$task" "times=$times" "interval=$interval" "backoff=$backoff"

    local attempt=1
    local current_interval=$interval

    while [[ $attempt -le $times ]]; do
        log-trace "Retry attempt $attempt of $times" "task=$task"
        _async-emit "$ASYNC_EVENT_RETRY" "task=$task" "attempt=$attempt" "max=$times"

        local result
        local exit_code=0

        # Execute task (handle both functions and commands)
        if typeset -f "$task" >/dev/null 2>&1; then
            # Direct function call (no subshell for state preservation)
            if result=$($task 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        else
            # Command string evaluation
            if result=$(eval "$task" 2>&1); then
                exit_code=0
            else
                exit_code=$?
            fi
        fi

        if [[ $exit_code -eq 0 ]]; then
            log-debug "Retry succeeded on attempt $attempt" "task=$task"
            echo "$result"
            return 0
        else
            log-warn "Retry attempt $attempt failed" "task=$task" "exit_code=$exit_code"

            if [[ $attempt -lt $times ]]; then
                log-trace "Waiting ${current_interval}s before retry"
                sleep "$current_interval"
                # Apply backoff
                current_interval=$(echo "$current_interval * $backoff" | bc 2>/dev/null || echo "$current_interval")
            fi
        fi

        ((attempt++))
    done

    log-error "Retry failed after $times attempts" "task=$task"
    return 1
}

# Execute task with timeout
#
# Function: async-timeout
# Description: Execute a task with a timeout limit
# Parameters:
#   $1 - Timeout in seconds
#   $2 - Task function or command
# Returns:
#   0 - Task completed within timeout
#   124 - Task timed out (timeout command exit code)
#   other - Task failed
# Output: Result of task if completed
# Example:
#   async-timeout 5 "long_running_command"
#
async-timeout() {
    local timeout_sec="$1"
    local task="$2"

    common-validate-required "$timeout_sec" "timeout" || return 2
    common-validate-required "$task" "task" || return 2

    log-debug "Timeout: executing task" "timeout=${timeout_sec}s" "task=$task"

    local result
    local exit_code=0

    if command -v timeout >/dev/null 2>&1; then
        # Use GNU timeout if available
        if result=$(timeout "$timeout_sec" bash -c "$task" 2>&1); then
            echo "$result"
            return 0
        else
            exit_code=$?
            if [[ $exit_code -eq 124 ]]; then
                log-error "Task timed out after ${timeout_sec}s" "task=$task"
            else
                log-error "Task failed" "task=$task" "exit_code=$exit_code"
            fi
            return $exit_code
        fi
    else
        # Fallback: manual timeout implementation
        local result_file=$(_async-mktemp)

        (
            eval "$task" > "$result_file" 2>&1
        ) &

        local pid=$!
        _async-track-job "$pid"

        local elapsed=0
        while kill -0 "$pid" 2>/dev/null; do
            if [[ $elapsed -ge $timeout_sec ]]; then
                kill "$pid" 2>/dev/null || true
                _async-untrack-job "$pid"
                log-error "Task timed out after ${timeout_sec}s" "task=$task"
                return 124
            fi
            sleep "$ASYNC_POLL_INTERVAL"
            elapsed=$(echo "$elapsed + $ASYNC_POLL_INTERVAL" | bc)
        done

        wait "$pid" 2>/dev/null || exit_code=$?
        _async-untrack-job "$pid"

        if [[ $exit_code -eq 0 ]]; then
            cat "$result_file"
            return 0
        else
            log-error "Task failed" "task=$task" "exit_code=$exit_code"
            return $exit_code
        fi
    fi
}

# ------------------------------
# Queue Management
# ------------------------------

# Create a task queue with concurrency control
#
# Function: async-queue-create
# Description: Create a managed queue for processing tasks
# Parameters:
#   $1 - Queue name
#   $2 - Worker function
#   $3 - Concurrency limit (default: 1)
# Returns:
#   0 - Queue created
#   4 - Queue already exists
# Example:
#   async-queue-create myqueue process_task 5
#
async-queue-create() {
    local queue_name="$1"
    local worker="$2"
    local concurrency="${3:-1}"

    common-validate-required "$queue_name" "queue name" || return 2
    common-validate-required "$worker" "worker function" || return 2

    if [[ -n "${_ASYNC_QUEUES[$queue_name]}" ]]; then
        log-warn "Queue already exists" "queue=$queue_name"
        return 4
    fi

    _ASYNC_QUEUES[$queue_name]="$worker:$concurrency"
    _ASYNC_QUEUE_TASKS[$queue_name]=0

    log-info "Created queue" "name=$queue_name" "worker=$worker" "concurrency=$concurrency"
    return 0
}

# Push task to queue
#
# Function: async-queue-push
# Description: Add a task to the queue for processing
# Parameters:
#   $1 - Queue name
#   $@ - Task arguments to pass to worker
# Returns:
#   0 - Task queued
#   3 - Queue not found
# Example:
#   async-queue-push myqueue arg1 arg2
#
async-queue-push() {
    local queue_name="$1"
    shift
    local -a task_args=("$@")

    common-validate-required "$queue_name" "queue name" || return 2

    if [[ -z "${_ASYNC_QUEUES[$queue_name]}" ]]; then
        log-error "Queue not found" "queue=$queue_name"
        return 3
    fi

    local queue_data="${_ASYNC_QUEUES[$queue_name]}"
    local worker="${queue_data%:*}"
    local concurrency="${queue_data#*:}"

    # Simple implementation: execute with concurrency limit
    # Note: A production implementation would use a proper task queue
    # with persistent storage and background worker processes

    (( _ASYNC_QUEUE_TASKS[$queue_name]++ ))

    # Execute with semaphore
    (
        _async-semaphore-acquire "queue:$queue_name" "$concurrency"
        $worker "${task_args[@]}"
        _async-semaphore-release "queue:$queue_name"

        (( _ASYNC_QUEUE_TASKS[$queue_name]-- ))

        # Emit drain event if queue is empty
        if [[ ${_ASYNC_QUEUE_TASKS[$queue_name]} -eq 0 ]]; then
            _async-emit "$ASYNC_EVENT_QUEUE_DRAIN" "queue=$queue_name"
        fi
    ) &

    local pid=$!
    _async-track-job "$pid"

    log-trace "Queued task" "queue=$queue_name" "pid=$pid"
    return 0
}

# Destroy a queue
#
# Function: async-queue-destroy
# Description: Remove a queue (waits for pending tasks)
# Parameters:
#   $1 - Queue name
# Returns:
#   0 - Queue destroyed
#   3 - Queue not found
# Example:
#   async-queue-destroy myqueue
#
async-queue-destroy() {
    local queue_name="$1"

    common-validate-required "$queue_name" "queue name" || return 2

    if [[ -z "${_ASYNC_QUEUES[$queue_name]}" ]]; then
        log-error "Queue not found" "queue=$queue_name"
        return 3
    fi

    # Wait for pending tasks
    log-debug "Waiting for queue to drain" "queue=$queue_name"
    while [[ ${_ASYNC_QUEUE_TASKS[$queue_name]:-0} -gt 0 ]]; do
        sleep "$ASYNC_POLL_INTERVAL"
    done

    unset "_ASYNC_QUEUES[$queue_name]"
    unset "_ASYNC_QUEUE_TASKS[$queue_name]"
    unset "_ASYNC_SEMAPHORES[queue:$queue_name]"

    log-info "Queue destroyed" "queue=$queue_name"
    return 0
}

# ------------------------------
# Memoization
# ------------------------------

# Memoize function results
#
# Function: async-memoize
# Description: Cache function results based on arguments
# Parameters:
#   $1 - Function to memoize
#   $@ - Arguments to function
# Returns:
#   Same as original function
# Output: Cached or computed result
# Example:
#   result=$(async-memoize expensive_function arg1 arg2)
#
async-memoize() {
    local func="$1"
    shift
    local -a args=("$@")

    common-validate-required "$func" "function" || return 2

    # Generate cache key from function name and arguments
    local cache_key="${func}:${(j:,:)args}"

    # Check cache
    if [[ "$ASYNC_CACHE_AVAILABLE" == "true" ]]; then
        local cached=$(cache-get "async:memo:$cache_key" 2>/dev/null)
        if [[ -n "$cached" ]]; then
            log-trace "Memoization cache hit" "func=$func"
            echo "$cached"
            return 0
        fi
    elif [[ -n "${_ASYNC_MEMO_CACHE[$cache_key]}" ]]; then
        log-trace "Memoization cache hit (internal)" "func=$func"
        echo "${_ASYNC_MEMO_CACHE[$cache_key]}"
        return 0
    fi

    # Execute function
    log-trace "Memoization cache miss, executing" "func=$func"
    local result
    local exit_code=0

    if result=$($func "${args[@]}" 2>&1); then
        # Cache result
        if [[ "$ASYNC_CACHE_AVAILABLE" == "true" ]]; then
            cache-set "async:memo:$cache_key" "$result" 3600 2>/dev/null || true
        else
            _ASYNC_MEMO_CACHE[$cache_key]="$result"
        fi

        echo "$result"
        return 0
    else
        exit_code=$?
        return $exit_code
    fi
}

# Clear memoization cache
#
# Function: async-memoize-clear
# Description: Clear all or specific memoized results
# Parameters:
#   $1 - Function name (optional, clears all if not specified)
# Example:
#   async-memoize-clear expensive_function
#
async-memoize-clear() {
    local func="${1:-}"

    if [[ "$ASYNC_CACHE_AVAILABLE" == "true" ]]; then
        if [[ -n "$func" ]]; then
            cache-clear-pattern "async:memo:${func}:*" 2>/dev/null || true
        else
            cache-clear-namespace "async:memo" 2>/dev/null || true
        fi
    else
        if [[ -n "$func" ]]; then
            # Clear specific function from internal cache
            for key in "${(@k)_ASYNC_MEMO_CACHE}"; do
                if [[ "$key" == "${func}:"* ]]; then
                    unset "_ASYNC_MEMO_CACHE[$key]"
                fi
            done
        else
            _ASYNC_MEMO_CACHE=()
        fi
    fi

    log-debug "Cleared memoization cache" "func=${func:-all}"
    return 0
}

# ------------------------------
# Cleanup and Lifecycle
# ------------------------------

# Cleanup all async resources
#
# Function: async-cleanup
# Description: Clean up background jobs and temporary resources
# Returns: 0 always
# Example:
#   async-cleanup
#
async-cleanup() {
    log-debug "Cleaning up async resources"

    # Kill active jobs if any
    if [[ ${#_ASYNC_ACTIVE_JOBS[@]} -gt 0 ]]; then
        log-debug "Killing ${#_ASYNC_ACTIVE_JOBS[@]} active background jobs"
        kill "${_ASYNC_ACTIVE_JOBS[@]}" 2>/dev/null || true
        _ASYNC_ACTIVE_JOBS=()
    fi

    # Cleanup temporary files
    _async-cleanup-temps

    # Clear state
    _ASYNC_JOB_RESULTS=()
    _ASYNC_JOB_ERRORS=()
    _ASYNC_JOB_STATUS=()
    _ASYNC_SEMAPHORES=()
    _ASYNC_QUEUES=()
    _ASYNC_QUEUE_TASKS=()

    log-debug "Async cleanup complete"
    return 0
}

# ------------------------------
# Help and Information
# ------------------------------

# Display help
#
# Usage: async-help
#
async-help() {
    cat <<EOF
_async - Asynchronous Control Flow and Parallel Execution Library

Version: $ASYNC_VERSION

USAGE:
  source "\$(which _async)"

CORE CONTROL FLOW:
  async-parallel [--limit N] [--timeout N] TASKS...
                                      Run tasks in parallel
  async-series [--stop-on-error] [--timeout N] TASKS...
                                      Run tasks sequentially
  async-waterfall TASKS...            Chain tasks, passing output

COLLECTION OPERATIONS:
  async-each [--limit N|--series] FUNC ITEMS...
                                      Iterate over items
  async-map [--limit N|--series] FUNC ITEMS...
                                      Transform items
  async-filter [--limit N|--series] PRED ITEMS...
                                      Filter items

UTILITIES:
  async-retry [--times N] [--interval N] [--backoff N] TASK
                                      Retry with exponential backoff
  async-timeout SECONDS TASK          Execute with timeout
  async-memoize FUNC ARGS...          Cache function results
  async-memoize-clear [FUNC]          Clear memoization cache

QUEUE MANAGEMENT:
  async-queue-create NAME WORKER [CONCURRENCY]
                                      Create task queue
  async-queue-push NAME ARGS...       Add task to queue
  async-queue-destroy NAME            Remove queue

SYSTEM:
  async-cleanup                       Clean up resources
  async-help                          Show this help
  async-info                          Show system info
  async-self-test                     Run self-tests

CONFIGURATION:
  ASYNC_DEFAULT_CONCURRENCY=$ASYNC_DEFAULT_CONCURRENCY
  ASYNC_DEFAULT_TIMEOUT=$ASYNC_DEFAULT_TIMEOUT
  ASYNC_RETRY_DEFAULT_TIMES=$ASYNC_RETRY_DEFAULT_TIMES
  ASYNC_DEBUG=$ASYNC_DEBUG

EXAMPLES:
  # Parallel execution
  async-parallel "echo task1" "echo task2" "echo task3"

  # Limited concurrency
  async-parallel --limit 2 "\${tasks[@]}"

  # Sequential execution
  async-series "step1" "step2" "step3"

  # Map transformation
  results=\$(async-map "process" item1 item2 item3)

  # Retry with backoff
  async-retry --times 5 "flaky_command"

  # Timeout
  async-timeout 10 "long_running_command"

  # Queue processing
  async-queue-create myqueue worker_func 5
  async-queue-push myqueue arg1 arg2

For detailed documentation: cat ~/.local/docs/lib/_async.md
EOF
}

# Display system information
#
# Usage: async-info
#
async-info() {
    cat <<EOF
_async Extension Information

Version:          $ASYNC_VERSION
Config Directory: $ASYNC_CONFIG_DIR
Cache Directory:  $ASYNC_CACHE_DIR
State Directory:  $ASYNC_STATE_DIR
Data Directory:   $ASYNC_DATA_DIR

Configuration:
  Debug Mode:           $ASYNC_DEBUG
  Verbose Mode:         $ASYNC_VERBOSE
  Dry Run:              $ASYNC_DRY_RUN
  Emit Events:          $ASYNC_EMIT_EVENTS
  Default Concurrency:  $ASYNC_DEFAULT_CONCURRENCY
  Default Timeout:      ${ASYNC_DEFAULT_TIMEOUT}s
  Retry Times:          $ASYNC_RETRY_DEFAULT_TIMES
  Retry Interval:       ${ASYNC_RETRY_DEFAULT_INTERVAL}s
  Auto Cleanup:         $ASYNC_AUTO_CLEANUP

Integration Status:
  _events:              ${ASYNC_EVENTS_AVAILABLE:-false}
  _lifecycle:           ${ASYNC_LIFECYCLE_AVAILABLE:-false}
  _cache:               ${ASYNC_CACHE_AVAILABLE:-false}

Runtime State:
  Active Jobs:          ${#_ASYNC_ACTIVE_JOBS[@]}
  Active Queues:        ${#_ASYNC_QUEUES[@]}
  Semaphores:           ${#_ASYNC_SEMAPHORES[@]}
  Temp Files:           ${#_ASYNC_TEMP_FILES[@]}
  Memo Cache Entries:   ${#_ASYNC_MEMO_CACHE[@]}

System Commands:
  timeout available:    $(command -v timeout >/dev/null && echo "yes" || echo "no")
  bc available:         $(command -v bc >/dev/null && echo "yes" || echo "no")
EOF
}

# Run self-tests
#
# Usage: async-self-test
#
async-self-test() {
    log-info "Running _async v$ASYNC_VERSION self-test..."
    local tests_passed=0
    local tests_failed=0

    # Test 1: Parallel execution
    log-info "Test 1: Parallel execution..."
    if async-parallel "echo test1" "echo test2" "echo test3" >/dev/null 2>&1; then
        log-info "✓ Parallel execution works"
        ((tests_passed++))
    else
        log-error "✗ Parallel execution failed"
        ((tests_failed++))
    fi

    # Test 2: Series execution
    log-info "Test 2: Series execution..."
    if async-series "echo test1" "echo test2" >/dev/null 2>&1; then
        log-info "✓ Series execution works"
        ((tests_passed++))
    else
        log-error "✗ Series execution failed"
        ((tests_failed++))
    fi

    # Test 3: Map operation
    log-info "Test 3: Map operation..."
    local result=$(async-map "echo" a b c 2>/dev/null)
    if [[ -n "$result" ]]; then
        log-info "✓ Map operation works"
        ((tests_passed++))
    else
        log-error "✗ Map operation failed"
        ((tests_failed++))
    fi

    # Test 4: Retry
    log-info "Test 4: Retry operation..."
    local retry_counter_file=$(_async-mktemp)
    echo "0" > "$retry_counter_file"
    _async_test_flaky_func() {
        local count=$(cat "$retry_counter_file")
        ((count++))
        echo "$count" > "$retry_counter_file"
        [[ $count -ge 2 ]] && return 0 || return 1
    }
    if async-retry --times 3 _async_test_flaky_func >/dev/null 2>&1; then
        local final_count=$(cat "$retry_counter_file")
        log-info "✓ Retry works (succeeded on attempt $final_count)"
        ((tests_passed++))
    else
        log-error "✗ Retry failed"
        ((tests_failed++))
    fi
    unfunction _async_test_flaky_func 2>/dev/null
    rm -f "$retry_counter_file" 2>/dev/null || true

    # Test 5: Timeout
    log-info "Test 5: Timeout operation..."
    if command -v timeout >/dev/null 2>&1; then
        if async-timeout 1 "sleep 0.1" >/dev/null 2>&1; then
            log-info "✓ Timeout works (task completed)"
            ((tests_passed++))
        else
            log-error "✗ Timeout failed"
            ((tests_failed++))
        fi
    else
        log-info "⚠ Timeout command not available (skipping timeout test)"
    fi

    # Test 6: Memoization
    log-info "Test 6: Memoization..."
    expensive_func() { echo "result:$1"; }
    local result1=$(async-memoize expensive_func arg1)
    local result2=$(async-memoize expensive_func arg1)
    if [[ "$result1" == "$result2" ]]; then
        log-info "✓ Memoization works"
        ((tests_passed++))
    else
        log-error "✗ Memoization failed"
        ((tests_failed++))
    fi
    unfunction expensive_func 2>/dev/null
    async-memoize-clear

    # Test 7: Cleanup
    log-info "Test 7: Cleanup..."
    if async-cleanup; then
        log-info "✓ Cleanup works"
        ((tests_passed++))
    else
        log-error "✗ Cleanup failed"
        ((tests_failed++))
    fi

    # Summary
    log-info ""
    log-info "Self-tests complete: $tests_passed passed, $tests_failed failed"

    if [[ $tests_failed -eq 0 ]]; then
        return 0
    else
        return 1
    fi
}

# ------------------------------
# Module Initialization
# ------------------------------

# Initialize directories
_async-init

# Register cleanup if lifecycle available and auto-cleanup enabled
if [[ "$ASYNC_LIFECYCLE_AVAILABLE" == "true" && "$ASYNC_AUTO_CLEANUP" == "true" ]]; then
    lifecycle-cleanup async-cleanup
fi

# Log module load
log-debug "_async extension loaded (version $ASYNC_VERSION)"
log-debug "Integrations: events=$ASYNC_EVENTS_AVAILABLE, lifecycle=$ASYNC_LIFECYCLE_AVAILABLE, cache=$ASYNC_CACHE_AVAILABLE"
