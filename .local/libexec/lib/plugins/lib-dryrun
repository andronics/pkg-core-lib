#!/usr/bin/env zsh

# lib-dryrun - Dry-run mode management and safe command execution
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Purpose:
#   Provides comprehensive dry-run mode management for safe command execution.
#   Supports mode toggling, conditional execution, and detailed logging of
#   would-be operations without actually performing them.
#
# Usage:
#   source || return 6
#
#   dryrun-enable
#   dryrun-exec rm -rf /important/file    # Simulated
#   dryrun-disable
#   dryrun-exec rm -rf /important/file    # Actually executed
#
# Provides:
#   - Global dry-run mode management
#   - Safe command execution wrappers
#   - Conditional execution based on mode
#   - Custom message support
#   - Scoped dry-run contexts
#   - File operation wrappers
#   - System operation wrappers
#
# Dependencies:
#   - _common v2.0 (required)
#   - _log v2.0 (optional, for structured logging)
#   - _events v2.0 (optional, for event emission)

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${_DRYRUN_LOADED}" ]] && return 0
declare -gr _DRYRUN_LOADED=1

# ------------------------------
# Version
# ------------------------------

declare -gr DRYRUN_VERSION="1.0.0"

# ------------------------------
# Load Dependencies
# ------------------------------

# Required: _common
if ! source 2>/dev/null; then
    echo "[ERROR] lib-dryrun requires _common v2.0" >&2
    return 6
fi

# Optional: _log (use fallbacks if unavailable)
if [[ -z "${_LOG_LOADED}" ]]; then
    source 2>/dev/null || {
        log-debug() { : ; }
        log-info() { echo "[INFO] $*" >&2; }
        log-warning() { echo "[WARNING] $*" >&2; }
        log-error() { echo "[ERROR] $*" >&2; }
    }
fi

# Optional: _events (graceful degradation)
[[ -z "${_EVENTS_LOADED}" ]] && source 2>/dev/null

# ------------------------------
# Constants
# ------------------------------

# Event types
declare -gr DRYRUN_EVENT_ENABLED="dryrun.enabled"
declare -gr DRYRUN_EVENT_DISABLED="dryrun.disabled"
declare -gr DRYRUN_EVENT_EXEC="dryrun.exec"
declare -gr DRYRUN_EVENT_SCOPE_ENTER="dryrun.scope.enter"
declare -gr DRYRUN_EVENT_SCOPE_EXIT="dryrun.scope.exit"

# Default prefix for dry-run messages
declare -gr DRYRUN_DEFAULT_PREFIX="[DRY-RUN]"

# Return codes
declare -gr DRYRUN_SUCCESS=0
declare -gr DRYRUN_ERROR=1

# ------------------------------
# State Variables
# ------------------------------

# Global dry-run mode flag (exported for child processes)
declare -g DRYRUN_ENABLED="${DRYRUN_ENABLED:-false}"
export DRYRUN_ENABLED

# Message prefix (customizable per session)
declare -g DRYRUN_PREFIX="${DRYRUN_PREFIX:-$DRYRUN_DEFAULT_PREFIX}"

# Scope nesting level (for nested scopes)
declare -g _DRYRUN_SCOPE_LEVEL=0

# ------------------------------
# Helper Functions
# ------------------------------

# Emit event if events are available
# Args: event_name, [args...]
_dryrun-emit() {
    [[ -n "${_EVENTS_LOADED}" ]] && events-emit "$@"
}

# ------------------------------
# Mode Control Functions
# ------------------------------

# Enable dry-run mode globally
# Usage: dryrun-enable
# Returns: 0
dryrun-enable() {
    DRYRUN_ENABLED=true
    export DRYRUN_ENABLED

    log-debug "Dry-run mode enabled"
    _dryrun-emit "$DRYRUN_EVENT_ENABLED"

    return $DRYRUN_SUCCESS
}

# Disable dry-run mode globally
# Usage: dryrun-disable
# Returns: 0
dryrun-disable() {
    DRYRUN_ENABLED=false
    export DRYRUN_ENABLED

    log-debug "Dry-run mode disabled"
    _dryrun-emit "$DRYRUN_EVENT_DISABLED"

    return $DRYRUN_SUCCESS
}

# Toggle dry-run mode
# Usage: dryrun-toggle
# Returns: 0
dryrun-toggle() {
    if dryrun-is-enabled; then
        dryrun-disable
    else
        dryrun-enable
    fi
}

# Check if dry-run mode is enabled
# Usage: dryrun-is-enabled && echo "In dry-run mode"
# Returns: 0 if enabled, 1 if disabled
dryrun-is-enabled() {
    [[ "$DRYRUN_ENABLED" == "true" ]]
}

# Set custom dry-run message prefix
# Args: prefix
# Usage: dryrun-set-prefix "[PREVIEW]"
# Returns: 0 on success, 1 on invalid input
dryrun-set-prefix() {
    local prefix="${1:?Prefix required}"

    DRYRUN_PREFIX="$prefix"
    log-debug "Dry-run prefix set to: $prefix"

    return $DRYRUN_SUCCESS
}

# Reset prefix to default
# Usage: dryrun-reset-prefix
# Returns: 0
dryrun-reset-prefix() {
    DRYRUN_PREFIX="$DRYRUN_DEFAULT_PREFIX"
    return $DRYRUN_SUCCESS
}

# ------------------------------
# Execution Functions
# ------------------------------

# Execute command with dry-run awareness
# In dry-run mode: prints what would be executed
# In live mode: actually executes the command
# Args: command [args...]
# Usage: dryrun-exec rm -rf /path/to/file
# Returns: 0 in dry-run, command exit code in live mode
dryrun-exec() {
    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX Would execute: $*"
        _dryrun-emit "$DRYRUN_EVENT_EXECsimulated$@"
        return $DRYRUN_SUCCESS
    else
        log-debug "Executing: $*"
        _dryrun-emit "$DRYRUN_EVENT_EXECexecuted$@$@"
    fi
}

# Execute command silently (no dry-run message)
# Useful for internal operations that shouldn't pollute output
# Args: command [args...]
# Usage: dryrun-exec-silent internal-helper-function
# Returns: 0 in dry-run, command exit code in live mode
dryrun-exec-silent() {
    if dryrun-is-enabled; then
        return $DRYRUN_SUCCESS
    else
        "$@"
    fi
}

# Execute command with custom dry-run message
# Args: message, command [args...]
# Usage: dryrun-exec-message "Deleting user files" rm -rf "$HOME/files"
# Returns: 0 in dry-run, command exit code in live mode
dryrun-exec-message() {
    local message="${1:?Message required}"
    shift

    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX $message"
        _dryrun-emit "$DRYRUN_EVENT_EXECsimulated$message"
        return $DRYRUN_SUCCESS
    else
        log-debug "$message"
        _dryrun-emit "$DRYRUN_EVENT_EXECexecuted$message$@"
    fi
}

# Execute only in live mode (skipped in dry-run)
# Args: command [args...]
# Usage: dryrun-when-live send-notification "Operation complete"
# Returns: 0 in dry-run, command exit code in live mode
dryrun-when-live() {
    if dryrun-is-enabled; then
        return $DRYRUN_SUCCESS
    else
        "$@"
    fi
}

# Execute only in dry-run mode (skipped in live)
# Args: command [args...]
# Usage: dryrun-when-dry echo "This is a preview"
# Returns: 0 in live mode, command exit code in dry-run mode
dryrun-when-dry() {
    if dryrun-is-enabled; then
        "$@"
    else
        return $DRYRUN_SUCCESS
    fi
}

# ------------------------------
# Message Functions
# ------------------------------

# Print message only in dry-run mode
# Args: message [args...]
# Usage: dryrun-message "Would delete file.txt"
# Returns: 0
dryrun-message() {
    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX $*"
    fi
    return $DRYRUN_SUCCESS
}

# Print informational message in dry-run mode
# Args: message [args...]
# Usage: dryrun-info "Processing 10 files"
# Returns: 0
dryrun-info() {
    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX [INFO] $*"
    fi
    return $DRYRUN_SUCCESS
}

# Print warning message in dry-run mode
# Args: message [args...]
# Usage: dryrun-warning "This operation is destructive"
# Returns: 0
dryrun-warning() {
    if dryrun-is-enabled; then
        log-warning "$DRYRUN_PREFIX [WARNING] $*"
    fi
    return $DRYRUN_SUCCESS
}

# ------------------------------
# Scope Management
# ------------------------------

# Execute commands in dry-run scope (temporarily enable)
# Preserves previous state and restores it after execution
# Args: command [args...]
# Usage: dryrun-scope dangerous-operation --force
# Returns: command exit code
dryrun-scope() {
    local was_enabled=false
    dryrun-is-enabled && was_enabled=true

    ((_DRYRUN_SCOPE_LEVEL++))
    log-debug "Entering dry-run scope (level $_DRYRUN_SCOPE_LEVEL)"
    _dryrun-emit "$DRYRUN_EVENT_SCOPE_ENTER$_DRYRUN_SCOPE_LEVEL"

    dryrun-enable
    "$@"
    local result=$?

    log-debug "Exiting dry-run scope (level $_DRYRUN_SCOPE_LEVEL)"
    _dryrun-emit "$DRYRUN_EVENT_SCOPE_EXIT$_DRYRUN_SCOPE_LEVEL"
    ((_DRYRUN_SCOPE_LEVEL--))

    [[ "$was_enabled" == "false" ]] && dryrun-disable

    return $result
}

# Execute commands in live scope (temporarily disable)
# Preserves previous state and restores it after execution
# Args: command [args...]
# Usage: dryrun-live-scope must-always-run-function
# Returns: command exit code
dryrun-live-scope() {
    local was_enabled=false
    dryrun-is-enabled && was_enabled=true

    ((_DRYRUN_SCOPE_LEVEL++))
    log-debug "Entering live scope (level $_DRYRUN_SCOPE_LEVEL)"

    dryrun-disable
    "$@"
    local result=$?

    log-debug "Exiting live scope (level $_DRYRUN_SCOPE_LEVEL)"
    ((_DRYRUN_SCOPE_LEVEL--))

    [[ "$was_enabled" == "true" ]] && dryrun-enable

    return $result
}

# ------------------------------
# File Operation Wrappers
# ------------------------------

# Dry-run aware file removal
# Args: file [files...]
# Usage: dryrun-rm /tmp/file1.txt /tmp/file2.txt
dryrun-rm() {
    dryrun-exec rm "$@"
}

# Dry-run aware recursive removal
# Args: path [paths...]
# Usage: dryrun-rm-rf /tmp/old-directory
dryrun-rm-rf() {
    dryrun-exec rm -rf "$@"
}

# Dry-run aware file move
# Args: source dest
# Usage: dryrun-mv old.txt new.txt
dryrun-mv() {
    dryrun-exec mv "$@"
}

# Dry-run aware file copy
# Args: source dest
# Usage: dryrun-cp source.txt backup.txt
dryrun-cp() {
    dryrun-exec cp "$@"
}

# Dry-run aware directory creation
# Args: directory [directories...]
# Usage: dryrun-mkdir /tmp/new-dir
dryrun-mkdir() {
    dryrun-exec mkdir "$@"
}

# Dry-run aware recursive directory creation
# Args: directory [directories...]
# Usage: dryrun-mkdir-p /tmp/path/to/new/dir
dryrun-mkdir-p() {
    dryrun-exec mkdir -p "$@"
}

# Dry-run aware file touch
# Args: file [files...]
# Usage: dryrun-touch /tmp/marker.txt
dryrun-touch() {
    dryrun-exec touch "$@"
}

# Dry-run aware permission change
# Args: mode file [files...]
# Usage: dryrun-chmod 755 script.sh
dryrun-chmod() {
    dryrun-exec chmod "$@"
}

# Dry-run aware ownership change
# Args: owner[:group] file [files...]
# Usage: dryrun-chown user:group file.txt
dryrun-chown() {
    dryrun-exec chown "$@"
}

# Dry-run aware symlink creation
# Args: target linkname
# Usage: dryrun-ln-s /usr/bin/program /usr/local/bin/program
dryrun-ln-s() {
    dryrun-exec ln -s "$@"
}

# ------------------------------
# Write Operation Wrappers
# ------------------------------

# Dry-run aware file write (from stdin)
# Args: file
# Usage: echo "content" | dryrun-write /tmp/file.txt
dryrun-write() {
    local file="${1:?File path required}"

    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX Would write to: $file"
        cat > /dev/null  # Consume stdin
        return $DRYRUN_SUCCESS
    else
        cat > "$file"
    fi
}

# Dry-run aware file append (from stdin)
# Args: file
# Usage: echo "content" | dryrun-append /tmp/file.txt
dryrun-append() {
    local file="${1:?File path required}"

    if dryrun-is-enabled; then
        log-info "$DRYRUN_PREFIX Would append to: $file"
        cat > /dev/null  # Consume stdin
        return $DRYRUN_SUCCESS
    else
        cat >> "$file"
    fi
}

# ------------------------------
# System Operation Wrappers
# ------------------------------

# Dry-run aware systemctl command
# Args: systemctl-args...
# Usage: dryrun-systemctl restart nginx
dryrun-systemctl() {
    dryrun-exec systemctl "$@"
}

# Dry-run aware package manager command (pacman)
# Args: pacman-args...
# Usage: dryrun-pacman -S package-name
dryrun-pacman() {
    dryrun-exec pacman "$@"
}

# Dry-run aware git command
# Args: git-args...
# Usage: dryrun-git commit -m "message"
dryrun-git() {
    dryrun-exec git "$@"
}

# ------------------------------
# Conditional Execution
# ------------------------------

# Execute command if condition is true (with dry-run awareness)
# Args: condition, command [args...]
# Usage: dryrun-if "test -f file.txt" rm file.txt
# Returns: 0 if condition false, command result if condition true
dryrun-if() {
    local condition="${1:?Condition required}"
    shift

    if eval "$condition" 2>/dev/null; then
        dryrun-exec "$@"
    else
        return $DRYRUN_SUCCESS
    fi
}

# ------------------------------
# Batch Operations
# ------------------------------

# Execute multiple commands sequentially
# Args: command-strings...
# Usage: dryrun-batch "rm file1rm file2rm file3"
# Returns: 0 on success, 1 if any command fails
dryrun-batch() {
    local cmd
    local failed=0

    for cmd in "$@"; do
        if ! dryrun-exec eval "$cmd"; then
            log-error "Batch command failed: $cmd"
            failed=1
        fi
    done

    return $failed
}

# Execute commands from file (one per line)
# Args: file-path
# Usage: dryrun-batch-file /tmp/commands.txt
# Returns: 0 on success, 1 if file not found or commands fail
dryrun-batch-file() {
    local file="${1:?File path required}"

    if [[ ! -f "$file" ]]; then
        log-error "Batch file not found: $file"
        return $DRYRUN_ERROR
    fi

    local cmd
    local failed=0

    while IFS= read -r cmd; do
        # Skip empty lines and comments
        [[ -z "$cmd" || "$cmd" == \#* ]] && continue

        if ! dryrun-exec eval "$cmd"; then
            log-error "Batch command failed: $cmd"
            failed=1
        fi
    done < "$file"

    return $failed
}

# ------------------------------
# Confirmation Helpers
# ------------------------------

# Require user confirmation (skipped in dry-run mode)
# Args: question
# Usage: dryrun-confirm "Delete all files?" && rm -rf *
# Returns: 0 in dry-run or if user confirms, 1 if user declines
dryrun-confirm() {
    local question="${1:?Question required}"

    # In dry-run mode, always simulate confirmation
    if dryrun-is-enabled; then
        dryrun-message "Would ask: $question"
        return $DRYRUN_SUCCESS
    fi

    # In live mode, actually prompt user
    local answer
    read -r "answer?$question (y/N): "
    [[ "${answer:l}" == "y" ]]
}

# ------------------------------
# Status Display
# ------------------------------

# Show current dry-run status
# Usage: dryrun-status
# Returns: 0
dryrun-status() {
    if dryrun-is-enabled; then
        echo "Dry-run mode: ${COLOR_GREEN}ENABLED${COLOR_NC}"
        echo "Prefix: $DRYRUN_PREFIX"
        echo "Scope level: $_DRYRUN_SCOPE_LEVEL"
    else
        echo "Dry-run mode: ${COLOR_RED}DISABLED${COLOR_NC}"
    fi
    return $DRYRUN_SUCCESS
}

# Get dry-run indicator string (empty if disabled)
# Usage: echo "$(dryrun-indicator) Starting operation"
# Returns: indicator string
dryrun-indicator() {
    if dryrun-is-enabled; then
        echo "$DRYRUN_PREFIX"
    fi
}

# ------------------------------
# Self-Test Function
# ------------------------------

# Comprehensive self-test for _dryrun
# Usage: dryrun-self-test
# Returns: 0 if all tests pass, 1 if any fail
dryrun-self-test() {
    echo "=== Testing _dryrun v$DRYRUN_VERSION ==="
    echo local failed=0

    # Test 1: Initial state
    echo "[TEST] Initial state"
    ! dryrun-is-enabled || { echo "  FAIL: Should start disabled"; failed=1; }
    echo "  PASS"
    echo # Test 2: Enable/disable
    echo "[TEST] Enable/disable operations"
    dryrun-enable
    dryrun-is-enabled || { echo "  FAIL: Enable failed"; failed=1; }
    dryrun-disable
    ! dryrun-is-enabled || { echo "  FAIL: Disable failed"; failed=1; }
    echo "  PASS"
    echo # Test 3: Toggle
    echo "[TEST] Toggle operation"
    dryrun-toggle
    dryrun-is-enabled || { echo "  FAIL: Toggle enable failed"; failed=1; }
    dryrun-toggle
    ! dryrun-is-enabled || { echo "  FAIL: Toggle disable failed"; failed=1; }
    echo "  PASS"
    echo # Test 4: Dry-run execution
    echo "[TEST] Dry-run execution"
    dryrun-enable
    dryrun-exec echo "This should be simulated" 2>&1 | grep -q "Would execute" || \
        { echo "  FAIL: Dry-run exec didn't simulate"; failed=1; }
    echo "  PASS"
    echo # Test 5: Live execution
    echo "[TEST] Live execution"
    dryrun-disable
    local test_output=$(dryrun-exec echo "test-output" 2>&1)
    [[ "$test_output" == "test-output" ]] || { echo "  FAIL: Live exec didn't execute"; failed=1; }
    echo "  PASS"
    echo # Test 6: Scoped execution
    echo "[TEST] Scoped execution"
    dryrun-disable
    dryrun-scope echo "scoped" 2>&1 | grep -q "Would execute" || \
        { echo "  FAIL: Scope didn't enable dry-run"; failed=1; }
    ! dryrun-is-enabled || { echo "  FAIL: Scope didn't restore state"; failed=1; }
    echo "  PASS"
    echo # Test 7: Custom prefix
    echo "[TEST] Custom prefix"
    dryrun-set-prefix "[TEST-PREFIX]"
    [[ "$DRYRUN_PREFIX" == "[TEST-PREFIX]" ]] || { echo "  FAIL: Prefix not set"; failed=1; }
    dryrun-reset-prefix
    [[ "$DRYRUN_PREFIX" == "$DRYRUN_DEFAULT_PREFIX" ]] || { echo "  FAIL: Prefix not reset"; failed=1; }
    echo "  PASS"
    echo # Test 8: Conditional execution (dryrun-when-*)
    echo "[TEST] Conditional execution"
    dryrun-enable
    local dry_result=$(dryrun-when-dry echo "dry-only" 2>&1)
    [[ "$dry_result" == "dry-only" ]] || { echo "  FAIL: when-dry didn't execute in dry mode"; failed=1; }
    dryrun-when-live echo "live-only" 2>&1 | grep -q . && \
        { echo "  FAIL: when-live executed in dry mode"; failed=1; }
    dryrun-disable
    echo "  PASS"
    echo # Test 9: Status display
    echo "[TEST] Status display"
    dryrun-status >/dev/null || { echo "  FAIL: Status display failed"; failed=1; }
    echo "  PASS"
    echo # Test 10: Indicator
    echo "[TEST] Indicator"
    dryrun-enable
    local indicator=$(dryrun-indicator)
    [[ -n "$indicator" ]] || { echo "  FAIL: Indicator empty when enabled"; failed=1; }
    dryrun-disable
    indicator=$(dryrun-indicator)
    [[ -z "$indicator" ]] || { echo "  FAIL: Indicator not empty when disabled"; failed=1; }
    echo "  PASS"
    echo # Summary
    if [[ $failed -eq 0 ]]; then
        echo "=== All tests PASSED ==="
        echo "_dryrun v$DRYRUN_VERSION"
        return $DRYRUN_SUCCESS
    else
        echo "=== Some tests FAILED ==="
        return $DRYRUN_ERROR
    fi
}

# ------------------------------
# Auto-run Self-Test
# ------------------------------

# Run self-test if executed directly (not sourced)
[[ "${ZSH_EVAL_CONTEXT}" == "toplevel" ]] && dryrun-self-test
