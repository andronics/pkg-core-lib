#!/usr/bin/env zsh

# lib-actions - Action registry, dispatcher, and execution engine
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Purpose:
#   Central action registry and execution engine for the schema-driven action
#   system. Registers action handlers from plugins, dispatches actions to
#   handlers, manages execution state, handles dependencies, and provides
#   rollback capabilities.
#
# Usage:
#   lib_load actions
#   action-register "docker.volume" "backup" "docker-volume-backup"
#   action-execute-schema "myschema.yaml"
#
# Features:
#   - Action handler registration
#   - Action dispatching to plugins
#   - Dependency-ordered execution (via _lifecycle)
#   - Pre/post hooks
#   - Execution state tracking
#   - Result storage and passing
#   - Best-effort rollback
#   - Conditional execution
#
# Dependencies:
#   - _common (required)
#   - _schema (required)
#   - _lifecycle (required for dependency ordering)
#   - _events (optional, for event emission)

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${ACTIONS_LOADED:-}" ]] && return 0

# ------------------------------
# Version
# ------------------------------

declare -gr ACTIONS_VERSION="1.0.0"
declare -g ACTIONS_LOADED=1

# ------------------------------
# Load Dependencies
# ------------------------------

# Load _common (required)
# Load lib-common (required) - look in same directory structure
_ACTIONS_COMMON_FOUND=false
_ACTIONS_SCRIPT_DIR="${%):-%x}:A:h}"

# Try core directory first, then plugins
for _ACTIONS_COMMON_PATH in \
    "${_ACTIONS_SCRIPT_DIR}/../core/lib-common" \
    "${_ACTIONS_SCRIPT_DIR}/lib-common" \
    "$HOME/.local/libexec/lib/core/lib-common" \
    "$HOME/.local/libexec/lib/plugins/lib-common"; do

    if [[ -f "${_ACTIONS_COMMON_PATH}" ]] && source "${_ACTIONS_COMMON_PATH}" 2>/dev/null; then
        _ACTIONS_COMMON_FOUND=true
        break
    fi
done

if [[ "${_ACTIONS_COMMON_FOUND}" != "true" ]]; then
    echo "[ERROR] lib-actions requires lib-common extension (searched multiple locations)" >&2
    return 1
fi
unset _ACTIONS_COMMON_FOUND _ACTIONS_COMMON_PATH _ACTIONS_SCRIPT_DIR

# ------------------------------
# Configuration Variables
# ------------------------------

# Execution behavior
declare -g ACTIONS_VERBOSE="${ACTIONS_VERBOSE:-false}"
declare -g ACTIONS_DEBUG="${ACTIONS_DEBUG:-false}"
declare -g ACTIONS_DRY_RUN="${ACTIONS_DRY_RUN:-false}"
declare -g ACTIONS_CONTINUE_ON_ERROR="${ACTIONS_CONTINUE_ON_ERROR:-false}"

# Rollback configuration
declare -g ACTIONS_ENABLE_ROLLBACK="${ACTIONS_ENABLE_ROLLBACK:-true}"
declare -g ACTIONS_ROLLBACK_STRATEGY="${ACTIONS_ROLLBACK_STRATEGY:-best-effort}"

# Hook execution
declare -g ACTIONS_ENABLE_HOOKS="${ACTIONS_ENABLE_HOOKS:-true}"

# ------------------------------
# Internal State
# ------------------------------

# Action registry: type.action => handler_function
declare -g -A _ACTIONS_REGISTRY=()

# Hook registry: type.action.phase => handler_function
declare -g -A _ACTIONS_HOOKS=()

# Execution state: action_id => state (pending|running|completed|failed|skipped)
declare -g -A _ACTIONS_STATE=()

# Execution results: action_id => result_data
declare -g -A _ACTIONS_RESULTS=()

# Execution context: variables available to all actions
declare -g -A _ACTIONS_CONTEXT=()

# Execution history: ordered list of executed actions
declare -g -a _ACTIONS_HISTORY=()

# Current execution ID
declare -g _ACTIONS_CURRENT_EXEC_ID=""

# Last error
declare -g ACTIONS_LAST_ERROR=""

# Statistics
declare -g _ACTIONS_TOTAL_REGISTERED=0
declare -g _ACTIONS_TOTAL_EXECUTIONS=0
declare -g _ACTIONS_TOTAL_SUCCESSES=0
declare -g _ACTIONS_TOTAL_FAILURES=0
declare -g _ACTIONS_TOTAL_SKIPPED=0

# ------------------------------
# Color Constants
# ------------------------------

declare -gr _ACTIONS_COLOR_ERROR="$COLOR_RED"
declare -gr _ACTIONS_COLOR_WARNING="$COLOR_YELLOW"
declare -gr _ACTIONS_COLOR_DEBUG="$COLOR_BLUE"
declare -gr _ACTIONS_COLOR_SUCCESS="$COLOR_GREEN"
declare -gr _ACTIONS_COLOR_INFO="$COLOR_CYAN"

# ------------------------------
# Internal Logging Functions
# ------------------------------

_actions-log-debug() {
    [[ "$ACTIONS_DEBUG" == "true" ]] || return 0
    echo -e "${_ACTIONS_COLOR_DEBUG}[DEBUG] actions: $*${COLOR_RESET}" >&2
}

_actions-log-verbose() {
    [[ "$ACTIONS_VERBOSE" == "true" ]] || return 0
    echo -e "${_ACTIONS_COLOR_INFO}[INFO] actions: $*${COLOR_RESET}" >&2
}

_actions-log-error() {
    echo -e "${_ACTIONS_COLOR_ERROR}[ERROR] actions: $*${COLOR_RESET}" >&2
    ACTIONS_LAST_ERROR="$*"
}

_actions-log-warning() {
    echo -e "${_ACTIONS_COLOR_WARNING}[WARNING] actions: $*${COLOR_RESET}" >&2
}

_actions-log-success() {
    [[ "$ACTIONS_VERBOSE" == "true" ]] || return 0
    echo -e "${_ACTIONS_COLOR_SUCCESS}[SUCCESS] actions: $*${COLOR_RESET}" >&2
}

# ------------------------------
# Event Emission
# ------------------------------

_actions-emit-event() {
    [[ "$_ACTIONS_HAS_EVENTS" == "true" ]] || return 0

    local event="$1"
    shift

    if typeset -f "events-emit" >/dev/null 2>&1; then
        events-emit "$event" "$@"
    fi
}

# ------------------------------
# Action Registration
# ------------------------------

# Register action handler
# Usage: action-register <type> <action> <handler_function>
action-register() {
    local type="$1"
    local action="$2"
    local handler="$3"

    common-validate-required "$type" "type" || return 2
    common-validate-required "$action" "action" || return 2
    common-validate-required "$handler" "handler" || return 2

    # Validate handler function exists
    if ! typeset -f "$handler" >/dev/null 2>&1; then
        _actions-log-error "Handler function does not exist: $handler"
        return 1
    fi

    local key="${type}.${action}"
    _ACTIONS_REGISTRY[$key]="$handler"
    ((_ACTIONS_TOTAL_REGISTERED++))

    _actions-log-debug "Registered action: $key => $handler"
    _actions-emit-event "actions.registered" "$type" "$action" "$handler"

    return 0
}

# Unregister action handler
action-unregister() {
    local type="$1"
    local action="$2"

    common-validate-required "$type" "type" || return 2
    common-validate-required "$action" "action" || return 2

    local key="${type}.${action}"
    if [[ -n "${_ACTIONS_REGISTRY[$key]}" ]]; then
        unset "_ACTIONS_REGISTRY[$key]"
        _actions-log-debug "Unregistered action: $key"
        return 0
    else
        _actions-log-warning "Action not registered: $key"
        return 1
    fi
}

# Check if action is registered
action-exists() {
    local type="$1"
    local action="$2"

    common-validate-required "$type" "type" || return 2
    common-validate-required "$action" "action" || return 2

    local key="${type}.${action}"
    [[ -n "${_ACTIONS_REGISTRY[$key]}" ]]
}

# List registered actions
action-list() {
    local type_filter="${1:-}"

    if [[ ${#_ACTIONS_REGISTRY[@]} -eq 0 ]]; then
        _actions-log-verbose "No actions registered"
        return 0
    fi

    echo "Registered Actions:"
    for key in "${(@k)_ACTIONS_REGISTRY}"; do
        if [[ -z "$type_filter" ]] || [[ "$key" == ${type_filter}.* ]]; then
            echo "  $key => ${_ACTIONS_REGISTRY[$key]}"
        fi
    done
}

# ------------------------------
# Hook Registration
# ------------------------------

# Register hook
# Usage: action-hook-register <type> <action> <phase> <handler>
action-hook-register() {
    local type="$1"
    local action="$2"
    local phase="$3"      # pre or post
    local handler="$4"

    common-validate-required "$type" "type" || return 2
    common-validate-required "$action" "action" || return 2
    common-validate-required "$phase" "phase" || return 2
    common-validate-required "$handler" "handler" || return 2

    if [[ "$phase" != "pre" ]] && [[ "$phase" != "post" ]]; then
        _actions-log-error "Hook phase must be 'pre' or 'post'"
        return 2
    fi

    if ! typeset -f "$handler" >/dev/null 2>&1; then
        _actions-log-error "Hook handler function does not exist: $handler"
        return 1
    fi

    local key="${type}.${action}.${phase}"
    _ACTIONS_HOOKS[$key]="$handler"

    _actions-log-debug "Registered hook: $key => $handler"
    return 0
}

# Execute hooks
_actions-execute-hooks() {
    local type="$1"
    local action="$2"
    local phase="$3"
    local action_context="$4"

    [[ "$ACTIONS_ENABLE_HOOKS" != "true" ]] && return 0

    local key="${type}.${action}.${phase}"

    if [[ -n "${_ACTIONS_HOOKS[$key]}" ]]; then
        local handler="${_ACTIONS_HOOKS[$key]}"
        _actions-log-debug "Executing $phase hook: $key"

        # Execute hook with action context
        "$handler" "$action_context"
        return $?
    fi

    return 0
}

# ------------------------------
# Execution Context
# ------------------------------

# Set context variable
action-context-set() {
    local key="$1"
    local value="$2"

    common-validate-required "$key" "key" || return 2

    _ACTIONS_CONTEXT[$key]="$value"
    _actions-log-debug "Set context: $key = $value"
}

# Get context variable
action-context-get() {
    local key="$1"
    local default="${2:-}"

    common-validate-required "$key" "key" || return 2

    echo "${_ACTIONS_CONTEXT[$key]:-$default}"
}

# Clear context
action-context-clear() {
    _ACTIONS_CONTEXT=()
    _actions-log-debug "Cleared execution context"
}

# ------------------------------
# Execution State Management
# ------------------------------

# Set action state
_actions-set-state() {
    local action_id="$1"
    local state="$2"

    _ACTIONS_STATE[$action_id]="$state"
    _actions-log-debug "Action $action_id: $state"
}

# Get action state
action-get-state() {
    local action_id="$1"

    common-validate-required "$action_id" "action_id" || return 2

    echo "${_ACTIONS_STATE[$action_id]:-unknown}"
}

# Store action result
_actions-store-result() {
    local action_id="$1"
    local result="$2"

    _ACTIONS_RESULTS[$action_id]="$result"
    _actions-log-debug "Stored result for action: $action_id"
}

# Get action result
action-get-result() {
    local action_id="$1"

    common-validate-required "$action_id" "action_id" || return 2

    echo "${_ACTIONS_RESULTS[$action_id]:-}"
}

# ------------------------------
# Condition Evaluation
# ------------------------------

# Evaluate condition expression
_actions-evaluate-condition() {
    local expression="$1"

    # Simple evaluation: check if variable is non-empty and not false/0
    # For complex expressions, would need to integrate with gomplate or eval

    # Strip {{ }} if present
    expression="${expression//\{\{/}"
    expression="${expression//\}\}/}"
    expression="${expression// /}"

    # Check if it's a context variable reference starting with .
    if [[ "$expression" =~ ^\. ]]; then
        local var_name="${expression#.}"
        local var_value=$(action-context-get "$var_name")

        if [[ -z "$var_value" ]] || [[ "$var_value" == "false" ]] || [[ "$var_value" == "0" ]]; then
            return 1
        else
            return 0
        fi
    fi

    # For now, treat as boolean
    if [[ "$expression" == "true" ]] || [[ "$expression" == "1" ]]; then
        return 0
    else
        return 1
    fi
}

# Check if action should be executed based on conditions
_actions-should-execute() {
    local action_json="$1"

    # Check if action has conditions
    if ! echo "$action_json" | /usr/bin/jq -e '.conditions' >/dev/null 2>&1; then
        return 0  # No conditions, should execute
    fi

    # Evaluate each condition
    local condition_count=$(echo "$action_json" | /usr/bin/jq -r '.conditions | length' 2>/dev/null)
    for ((i=0; i<condition_count; i++)); do
        local condition=$(echo "$action_json" | /usr/bin/jq -r ".conditions[$i]" 2>/dev/null)
        local expression=$(echo "$condition" | /usr/bin/jq -r '.expression' 2>/dev/null)
        local on_false=$(echo "$condition" | /usr/bin/jq -r '.on_false // "skip"' 2>/dev/null)

        if ! _actions-evaluate-condition "$expression"; then
            _actions-log-verbose "Condition failed: $expression (action: $on_false)"

            case "$on_false" in
                skip)
                    return 1  # Don't execute
                    ;;
                fail)
                    _actions-log-error "Condition failed (configured to fail): $expression"
                    return 2  # Error
                    ;;
                warn)
                    _actions-log-warning "Condition failed (continuing): $expression"
                    return 0  # Execute anyway
                    ;;
            esac
        fi
    done

    return 0  # All conditions passed
}

# ------------------------------
# Action Execution
# ------------------------------

# Execute single action
_actions-execute-one() {
    local action_json="$1"

    # Extract action details
    local action_id=$(echo "$action_json" | /usr/bin/jq -r '.id' 2>/dev/null)
    local action_type=$(echo "$action_json" | /usr/bin/jq -r '.type' 2>/dev/null)
    local action_name=$(echo "$action_json" | /usr/bin/jq -r '.action' 2>/dev/null)
    local resource=$(echo "$action_json" | /usr/bin/jq -r '.resource // empty' 2>/dev/null)
    local selector=$(echo "$action_json" | /usr/bin/jq -r '.selector // empty' 2>/dev/null)
    local params=$(echo "$action_json" | /usr/bin/jq -r '.params // {}' 2>/dev/null)
    local on_error=$(echo "$action_json" | /usr/bin/jq -r '.on_error // "fail"' 2>/dev/null)
    local store_as=$(echo "$action_json" | /usr/bin/jq -r '.store_result_as // empty' 2>/dev/null)

    _actions-log-verbose "Executing action: $action_id ($action_type.$action_name)"
    _actions-emit-event "actions.execute.start" "$action_id" "$action_type" "$action_name"

    # Check if registered
    local handler_key="${action_type}.${action_name}"
    if [[ -z "${_ACTIONS_REGISTRY[$handler_key]}" ]]; then
        _actions-log-error "Action not registered: $handler_key"
        _actions-set-state "$action_id" "failed"
        return 1
    fi

    # Check conditions
    _actions-should-execute "$action_json"
    local condition_result=$?
    if [[ $condition_result -eq 1 ]]; then
        _actions-log-verbose "Skipping action (condition not met): $action_id"
        _actions-set-state "$action_id" "skipped"
        ((_ACTIONS_TOTAL_SKIPPED++))
        _actions-emit-event "actions.execute.skipped" "$action_id"
        return 0
    elif [[ $condition_result -eq 2 ]]; then
        _actions-set-state "$action_id" "failed"
        return 1
    fi

    # Dry run mode
    if [[ "$ACTIONS_DRY_RUN" == "true" ]]; then
        _actions-log-verbose "[DRY RUN] Would execute: $action_id"
        _actions-set-state "$action_id" "completed"
        return 0
    fi

    # Execute pre-hooks
    _actions-execute-hooks "$action_type" "$action_name" "pre" "$action_json"

    # Set running state
    _actions-set-state "$action_id" "running"

    # Get handler function
    local handler="${_ACTIONS_REGISTRY[$handler_key]}"

    # Execute handler
    local result
    local exit_code
    _actions-log-debug "Calling handler: $handler"

    # Call handler with resource/selector and params
    if [[ -n "$resource" ]]; then
        result=$("$handler" "$resource" "$params" 2>&1)
        exit_code=$?
    elif [[ -n "$selector" ]]; then
        result=$("$handler" "$selector" "$params" 2>&1)
        exit_code=$?
    else
        _actions-log-error "Action must have 'resource' or 'selector'"
        _actions-set-state "$action_id" "failed"
        return 1
    fi

    # Handle result
    if [[ $exit_code -eq 0 ]]; then
        _actions-log-success "Action completed: $action_id"
        _actions-set-state "$action_id" "completed"
        ((_ACTIONS_TOTAL_SUCCESSES++))

        # Store result if requested
        if [[ -n "$store_as" ]]; then
            _actions-store-result "$action_id" "$result"
            action-context-set "$store_as" "$result"
        fi

        # Execute post-hooks
        _actions-execute-hooks "$action_type" "$action_name" "post" "$action_json"

        _actions-emit-event "actions.execute.success" "$action_id"
        return 0
    else
        _actions-log-error "Action failed: $action_id (exit code: $exit_code)"
        _actions-log-error "Error output: $result"
        _actions-set-state "$action_id" "failed"
        ((_ACTIONS_TOTAL_FAILURES++))

        _actions-emit-event "actions.execute.failed" "$action_id" "$exit_code"

        # Handle error based on on_error config
        case "$on_error" in
            warn)
                _actions-log-warning "Continuing despite error (on_error: warn)"
                return 0
                ;;
            ignore)
                _actions-log-debug "Ignoring error (on_error: ignore)"
                return 0
                ;;
            fail|*)
                return 1
                ;;
        esac
    fi
}

# Execute actions from schema with dependency ordering
action-execute-schema() {
    local schema_file="$1"

    common-validate-required "$schema_file" "schema_file" || return 2

    # Load and validate schema
    _actions-log-verbose "Loading schema: $schema_file"
    # Call schema-load directly (not in subshell) so it can set _SCHEMA_CURRENT
    schema-load "$schema_file" >/dev/null
    if [[ $? -ne 0 ]]; then
        _actions-log-error "Failed to load schema"
        return 1
    fi

    # Validate schema
    echo "[DEBUG action-execute-schema] Validating schema..." >&2
    if ! schema-validate "$schema_file" >&2; then
        echo "[DEBUG action-execute-schema] Validation returned non-zero" >&2
        _actions-log-error "Schema validation failed"
        return 1
    fi
    echo "[DEBUG action-execute-schema] Validation passed" >&2

    # Generate execution ID
    _ACTIONS_CURRENT_EXEC_ID="exec_$(/bin/date +%s)_$$"

    # Clear previous execution state
    _ACTIONS_STATE=()
    _ACTIONS_RESULTS=()
    _ACTIONS_HISTORY=()

    # Get actions
    echo "[DEBUG action-execute-schema] Getting actions..." >&2
    echo "[DEBUG action-execute-schema] _SCHEMA_CURRENT[json] length: ${#_SCHEMA_CURRENT[json]}" >&2
    local actions=$(schema-get-actions)
    echo "[DEBUG action-execute-schema] Got actions, length: ${#actions}" >&2
    local action_count=$(echo "$actions" | /usr/bin/jq -r 'length' 2>/dev/null)
    echo "[DEBUG action-execute-schema] Action count: $action_count" >&2

    _actions-log-verbose "Executing $action_count actions"
    ((_ACTIONS_TOTAL_EXECUTIONS++))

    _actions-emit-event "actions.schema.execute.start" "$schema_file" "$action_count"

    # Build dependency graph and execution order using _lifecycle
    _actions-log-debug "Building dependency graph"

    # Register all actions with lifecycle
    echo "[DEBUG action-execute-schema] Registering $action_count actions with lifecycle..." >&2
    for ((i=0; i<action_count; i++)); do
        local action=$(echo "$actions" | /usr/bin/jq -r ".[$i]" 2>/dev/null)
        local action_id=$(echo "$action" | /usr/bin/jq -r '.id' 2>/dev/null)
        local depends_on=$(echo "$action" | /usr/bin/jq -r '.depends_on[]? // empty' 2>/dev/null)

        echo "[DEBUG action-execute-schema] Registering action $i: $action_id" >&2

        # Create cleanup function for action
        local cleanup_func="_actions_cleanup_${action_id}"
        eval "$cleanup_func() { _actions-log-debug 'Cleanup: $action_id'; }"

        # Register with lifecycle
        if [[ -n "$depends_on" ]]; then
            echo "[DEBUG action-execute-schema] Action has dependencies: $depends_on" >&2
            local -a deps=()
            while IFS= read -r dep; do
                deps+=("$dep")
            done <<< "$depends_on"

            lifecycle-cleanup-add "$action_id" "$cleanup_func" "${deps[@]}"
        else
            echo "[DEBUG action-execute-schema] Action has no dependencies, registering..." >&2
            lifecycle-cleanup-add "$action_id" "$cleanup_func"
        fi
        echo "[DEBUG action-execute-schema] Registered action: $action_id" >&2

        # Set initial state
        _actions-set-state "$action_id" "pending"
    done

    # Get execution order
    echo "[DEBUG action-execute-schema] Getting execution order..." >&2
    local execution_order=$(lifecycle-cleanup-order 2>/dev/null)
    echo "[DEBUG action-execute-schema] Execution order output: '$execution_order'" >&2
    _actions-log-debug "Execution order: $execution_order"

    # Execute actions in order
    local failed=false
    while IFS= read -r action_line; do
        [[ -z "$action_line" ]] && continue

        # Extract just the action ID (strip dependency info if present)
        local action_id="${action_line%% \(*}"  # Remove " (depends on: ...)" suffix

        # Find action JSON
        local action=$(echo "$actions" | /usr/bin/jq -r ".[] | select(.id == \"$action_id\")" 2>/dev/null)

        if [[ -z "$action" ]]; then
            _actions-log-error "Action not found in schema: $action_id"
            failed=true
            break
        fi

        # Execute action
        if ! _actions-execute-one "$action"; then
            failed=true

            if [[ "$ACTIONS_CONTINUE_ON_ERROR" != "true" ]]; then
                _actions-log-error "Execution stopped due to failure"
                break
            fi
        fi

        # Add to history
        _ACTIONS_HISTORY+=("$action_id")
    done <<< "$execution_order"

    # Handle execution result
    if [[ "$failed" == "true" ]]; then
        _actions-log-error "Schema execution failed"
        _actions-emit-event "actions.schema.execute.failed" "$schema_file"

        # Attempt rollback if enabled
        if [[ "$ACTIONS_ENABLE_ROLLBACK" == "true" ]]; then
            _actions-log-warning "Attempting rollback..."
            _actions-rollback-schema "$schema_json"
        fi

        return 1
    else
        _actions-log-success "Schema execution completed successfully"
        _actions-emit-event "actions.schema.execute.success" "$schema_file"
        return 0
    fi
}

# ------------------------------
# Rollback
# ------------------------------

# Execute rollback actions
_actions-rollback-schema() {
    local schema_json="$1"

    _actions-log-verbose "Executing rollback"
    _actions-emit-event "actions.rollback.start"

    # Check if rollback is defined in schema
    if ! echo "$schema_json" | /usr/bin/jq -e '.rollback.enabled' >/dev/null 2>&1; then
        _actions-log-debug "No rollback defined in schema"
        return 0
    fi

    local rollback_enabled=$(echo "$schema_json" | /usr/bin/jq -r '.rollback.enabled' 2>/dev/null)
    if [[ "$rollback_enabled" != "true" ]]; then
        _actions-log-debug "Rollback disabled in schema"
        return 0
    fi

    # Get rollback actions
    local rollback_actions=$(echo "$schema_json" | /usr/bin/jq -r '.rollback.actions // []' 2>/dev/null)
    local rollback_count=$(echo "$rollback_actions" | /usr/bin/jq -r 'length' 2>/dev/null)

    if [[ $rollback_count -eq 0 ]]; then
        _actions-log-debug "No rollback actions defined"
        return 0
    fi

    _actions-log-verbose "Executing $rollback_count rollback actions"

    # Execute rollback actions (in reverse order typically)
    for ((i=rollback_count-1; i>=0; i--)); do
        local action=$(echo "$rollback_actions" | /usr/bin/jq -r ".[$i]" 2>/dev/null)
        _actions-execute-one "$action" || true  # Continue even if rollback fails
    done

    _actions-emit-event "actions.rollback.complete"
    return 0
}

# ------------------------------
# Utilities
# ------------------------------

# Get last error
action-get-error() {
    echo "$ACTIONS_LAST_ERROR"
}

# Clear execution state
action-clear-state() {
    _ACTIONS_STATE=()
    _ACTIONS_RESULTS=()
    _ACTIONS_CONTEXT=()
    _ACTIONS_HISTORY=()
    _ACTIONS_CURRENT_EXEC_ID=""
    _actions-log-debug "Cleared execution state"
}

# Get execution history
action-get-history() {
    if [[ ${#_ACTIONS_HISTORY[@]} -eq 0 ]]; then
        _actions-log-debug "No execution history"
        return 1
    fi

    for action_id in "${_ACTIONS_HISTORY[@]}"; do
        echo "$action_id"
    done
}

# ------------------------------
# Statistics
# ------------------------------

action-stats() {
    echo "Actions Engine Statistics:"
    echo "  Version: $ACTIONS_VERSION"
    echo "  Registered Actions: ${#_ACTIONS_REGISTRY[@]}"
    echo "  Registered Hooks: ${#_ACTIONS_HOOKS[@]}"
    echo "  Total Executions: $_ACTIONS_TOTAL_EXECUTIONS"
    echo "  Total Successes: $_ACTIONS_TOTAL_SUCCESSES"
    echo "  Total Failures: $_ACTIONS_TOTAL_FAILURES"
    echo "  Total Skipped: $_ACTIONS_TOTAL_SKIPPED"
    echo "  Current Execution: ${_ACTIONS_CURRENT_EXEC_ID:-none}"
    echo "  Dry Run Mode: $ACTIONS_DRY_RUN"
    echo "  Continue On Error: $ACTIONS_CONTINUE_ON_ERROR"
    echo "  Rollback Enabled: $ACTIONS_ENABLE_ROLLBACK"
}

# ------------------------------
# Help
# ------------------------------

action-help() {
    cat <<'EOF'
actions - Action registry, dispatcher, and execution engine
Version: 1.0.0

Usage:
  lib_load actions
  action-register "docker.volume" "backup" "docker-volume-backup"
  action-execute-schema "myschema.yaml"

Registration:
  action-register <type> <action> <handler>      Register action handler
  action-unregister <type> <action>              Unregister action handler
  action-exists <type> <action>                  Check if action registered
  action-list [type_filter]                      List registered actions

Hooks:
  action-hook-register <type> <action> <phase> <handler>
                                                 Register pre/post hook

Execution:
  action-execute-schema <schema_file>            Execute actions from schema

Context Management:
  action-context-set <key> <value>               Set execution context variable
  action-context-get <key> [default]             Get context variable
  action-context-clear                           Clear context

State Queries:
  action-get-state <action_id>                   Get action execution state
  action-get-result <action_id>                  Get action result
  action-get-history                             Get execution history
  action-clear-state                             Clear execution state

Utilities:
  action-get-error                               Get last error
  action-stats                                   Show statistics
  action-help                                    Show this help

Configuration:
  ACTIONS_VERBOSE=true/false                     Verbose output
  ACTIONS_DEBUG=true/false                       Debug output
  ACTIONS_DRY_RUN=true/false                     Dry run mode (don't execute)
  ACTIONS_CONTINUE_ON_ERROR=true/false           Continue on action failure
  ACTIONS_ENABLE_ROLLBACK=true/false             Enable rollback on failure
  ACTIONS_ENABLE_HOOKS=true/false                Enable pre/post hooks

Action States:
  pending    - Action registered, not yet executed
  running    - Action currently executing
  completed  - Action executed successfully
  failed     - Action execution failed
  skipped    - Action skipped (condition not met)

Handler Function Signature:
  handler_function <resource_or_selector> <params_json>

  Returns: 0 on success, non-zero on failure
  Output: Result data (captured if store_result_as is set)

Example Handler:
  docker-volume-backup() {
      local volume_name="$1"
      local params="$2"

      local destination=$(echo "$params" | /usr/bin/jq -r '.destination')

      # Execute backup
      docker run --rm -v "$volume_name:/data" \
          -v "$destination:/backup" \
          alpine tar czf "/backup/backup.tar.gz" /data

      return $?
  }

Example Registration:
  action-register "docker.volume" "backup" "docker-volume-backup"
  action-register "docker.volume" "remove" "docker-volume-remove"
  action-register "docker.container" "stop" "docker-container-stop"

Example Hook:
  verify-volume-exists() {
      local action_json="$1"
      local volume=$(echo "$action_json" | /usr/bin/jq -r '.resource')
      docker volume inspect "$volume" >/dev/null 2>&1
  }

  action-hook-register "docker.volume" "remove" "pre" "verify-volume-exists"

Dependencies:
  Required: _common, _schema, _lifecycle
  Optional: _events (for event emission)

EOF
}

# ------------------------------
# Script Execution Detection
# ------------------------------

if [[ "${ZSH_EVAL_CONTEXT}" == *:file || "${ZSH_EVAL_CONTEXT}" == "file" ]]; then
    # Sourced, don't run anything
    :
elif [[ "${ZSH_EVAL_CONTEXT}" == "" || "${(%):-%x}" == "$0" ]]; then
    # Executed directly
    case "${1:-help}" in
        help|--help|-h)
            action-help
            exit 0
            ;;
        stats)
            action-stats
            exit 0
            ;;
        list)
            action-list "${2:-}"
            exit 0
            ;;
        *)
            echo "Error: Extension must be sourced, not executed directly" >&2
            echo "Usage: source \"$(which _actions)\"" >&2
            echo "For help: $0 help" >&2
            exit 1
            ;;
    esac
fi

# ------------------------------
# Extension Loaded
# ------------------------------

_actions-log-debug "Extension loaded successfully"
