#!/usr/bin/env zsh

# lib-dispatcher - Git-like subcommand dispatcher and routing system
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Usage:
#   lib_load dispatcher
#   dispatcher-init "mycommand"
#   dispatcher-execute "$@"
#
# Provides:
#   - Git-like command routing (mycommand subcommand args)
#   - Automatic subcommand discovery
#   - Help and version handling
#   - Command listing with descriptions
#   - Global flag parsing (--verbose, --debug, --dry-run)
#   - Middleware/hook system
#   - Bash completion generation
#   - Command aliases
#   - Command validation
#   - Error handling
#
# Examples:
#   mycommand list          # Routes to mycommand-list
#   mycommand add item      # Routes to mycommand-add with args
#   mycommand help          # Shows help
#   mycommand commands      # Lists all available commands
#
# Dependencies:
#   Required:
#     - _common v2.0: Core utilities
#   Optional (gracefully degraded):
#     - _log v2.0: Logging functions
#     - _events v2.0: Event emission
#     - _lifecycle v3.0: Cleanup registration

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${_DISPATCHER_LOADED}" ]] && return 0
declare -gr _DISPATCHER_LOADED=1

# ------------------------------
# Version
# ------------------------------

declare -gr DISPATCHER_VERSION="1.0.0"

# ------------------------------
# Dependency Loading
# ------------------------------

# Load foundation (required)
if ! source 2>/dev/null; then
    echo "[ERROR] lib-dispatcher requires _common - cannot load" >&2
    return 1
fi

# Load infrastructure (optional with fallbacks)
if ! source 2>/dev/null; then
    # Fallback logging
    log-info() { echo "[INFO] $*"; }
    log-error() { echo "[ERROR] $*" >&2; }
    log-warn() { echo "[WARN] $*" >&2; }
    log-debug() { [[ "${DISPATCHER_DEBUG:-false}" == "true" ]] && echo "[DEBUG] $*" >&2 || true; }
    log-success() { echo "[SUCCESS] $*"; }
fi

# Load optional dependencies
source 2>/dev/null
declare -g DISPATCHER_EVENTS_AVAILABLE=$(common-command-exists "events-emit" && echo "true" || echo "false")

source 2>/dev/null
declare -g DISPATCHER_LIFECYCLE_AVAILABLE=$(common-command-exists "lifecycle-add-cleanup" && echo "true" || echo "false")

# ------------------------------
# Configuration
# ------------------------------

# Global state
declare -g DISPATCHER_NAME=declare -g DISPATCHER_BIN_DIR=declare -g DISPATCHER_VERSION_STRING=declare -g DISPATCHER_DESCRIPTION=# Behavior flags (can be set by global flag parsing)
declare -g DISPATCHER_VERBOSE="${DISPATCHER_VERBOSE:-false}"
declare -g DISPATCHER_DEBUG="${DISPATCHER_DEBUG:-false}"
declare -g DISPATCHER_DRY_RUN="${DISPATCHER_DRY_RUN:-false}"

# Command cache (for performance)
declare -g -A _DISPATCHER_COMMAND_CACHE=()

# Command aliases (command -> actual_command)
declare -g -A _DISPATCHER_ALIASES=()

# Middleware/hooks (before/after command execution)
declare -g -a _DISPATCHER_BEFORE_HOOKS=()
declare -g -a _DISPATCHER_AFTER_HOOKS=()

# ------------------------------
# Initialization
# ------------------------------

# Initialize the dispatcher
# Must be called before any other dispatcher functions
#
# Usage: dispatcher-init "mycommand" [bin_dir] [version] [description]
#
# Arguments:
#   $1 - Command name (required)
#   $2 - Bin directory (optional, auto-detected if not provided)
#   $3 - Version string (optional, e.g., "1.0.0")
#   $4 - Description (optional, shown in help)
#
dispatcher-init() {
    local name="${1}"
    local bin_dir="${2}"
    local version="${3:-unknown}"
    local description="${4:-}"

    # Validate command name
    if [[ -z "$name" ]]; then
        log-error "Command name required"
        return 1
    fi

    DISPATCHER_NAME="$name"
    DISPATCHER_VERSION_STRING="$version"
    DISPATCHER_DESCRIPTION="$description"

    # Auto-detect bin directory if not provided
    if [[ -z "$bin_dir" ]]; then
        # Try to detect from calling script
        if [[ -n "${(%):-%x}" ]]; then
            bin_dir="$(dirname "$(realpath "${(%):-%x}")")"
        else
            bin_dir="$(pwd)"
        fi
    fi

    DISPATCHER_BIN_DIR="$bin_dir"

    # Export for subcommands to use
    export DISPATCHER_NAME
    export DISPATCHER_BIN_DIR
    export DISPATCHER_VERSION_STRING

    log-debug "Dispatcher initialized: $name (bin: $bin_dir, version: $version)"
}

# Check if dispatcher is properly initialized
# Usage: dispatcher-check-init || return 1
dispatcher-check-init() {
    if [[ -z "$DISPATCHER_NAME" ]]; then
        log-error "Dispatcher not initialized - call dispatcher-init first"
        return 1
    fi
}

# ------------------------------
# Command Discovery
# ------------------------------

# Find a subcommand executable
# Returns the full path if found, empty string otherwise
#
# Usage: cmd_path=$(dispatcher-find-command "list")
#
dispatcher-find-command() {
    local command="${1}"

    if [[ -z "$command" ]]; then
        return 1
    fi

    # Check cache first
    if [[ -n "${_DISPATCHER_COMMAND_CACHE[$command]}" ]]; then
        echo "${_DISPATCHER_COMMAND_CACHE[$command]}"
        return 0
    fi

    local cmd_path="${DISPATCHER_BIN_DIR}/${DISPATCHER_NAME}-${command}"

    if [[ -x "$cmd_path" ]]; then
        # Cache the result
        _DISPATCHER_COMMAND_CACHE[$command]="$cmd_path"
        echo "$cmd_path"
        return 0
    fi

    return 1
}

# Check if a command exists
# Usage: dispatcher-command-exists "list" && echo "exists"
dispatcher-command-exists() {
    local command="${1}"
    [[ -n "$(dispatcher-find-command "$command" 2>/dev/null)" ]]
}

# Get all available subcommands
# Returns array of command names (without prefix)
#
# Usage: commands=($(dispatcher-get-commands))
#
dispatcher-get-commands() {
    local -a commands=()

    for cmd in "${DISPATCHER_BIN_DIR}/${DISPATCHER_NAME}"-*; do
        if [[ -x "$cmd" ]]; then
            local cmd_name=$(basename "$cmd")
            # Remove prefix
            cmd_name="${cmd_name#${DISPATCHER_NAME}-}"
            # Skip if it's the main dispatcher itself
            [[ "$cmd_name" == "$DISPATCHER_NAME" ]] && continue
            commands+=("$cmd_name")
        fi
    done

    echo "${commands[@]}"
}

# Count available subcommands
# Usage: count=$(dispatcher-count-commands)
dispatcher-count-commands() {
    local commands=($(dispatcher-get-commands))
    echo "${#commands[@]}"
}

# Get command description from subcommand script
# Looks for a comment line starting with # Description: in the script
#
# Usage: desc=$(dispatcher-get-command-description "list")
#
dispatcher-get-command-description() {
    local command="${1}"
    local cmd_path=$(dispatcher-find-command "$command" 2>/dev/null)

    if [[ -n "$cmd_path" ]] && [[ -f "$cmd_path" ]]; then
        grep -m 1 "^# Description:$cmd_path" 2>/dev/null | sed 's/^# Description: *//'
    fi
}

# ------------------------------
# Command Aliases
# ------------------------------

# Register command alias
# Usage: dispatcher-register-alias "lslist"
dispatcher-register-alias() {
    local alias_name="${1}"
    local actual_command="${2}"

    if [[ -z "$alias_name" ]] || [[ -z "$actual_command" ]]; then
        log-error "Alias name and actual command required"
        return 1
    fi

    _DISPATCHER_ALIASES[$alias_name]="$actual_command"
    log-debug "Registered alias: $alias_name -> $actual_command"
}

# Resolve alias to actual command
# Usage: actual=$(dispatcher-resolve-alias "ls")
dispatcher-resolve-alias() {
    local command="${1}"
    echo "${_DISPATCHER_ALIASES[$command]:-$command}"
}

# ------------------------------
# Middleware/Hooks
# ------------------------------

# Register before-command hook
# Usage: dispatcher-before "function_name"
dispatcher-before() {
    local hook="${1}"

    if [[ -z "$hook" ]]; then
        log-error "Hook function required"
        return 1
    fi

    _DISPATCHER_BEFORE_HOOKS+=("$hook")
    log-debug "Registered before hook: $hook"
}

# Register after-command hook
# Usage: dispatcher-after "function_name"
dispatcher-after() {
    local hook="${1}"

    if [[ -z "$hook" ]]; then
        log-error "Hook function required"
        return 1
    fi

    _DISPATCHER_AFTER_HOOKS+=("$hook")
    log-debug "Registered after hook: $hook"
}

# Execute before hooks
_dispatcher-run-before-hooks() {
    local command="${1}"
    shift

    for hook in "${_DISPATCHER_BEFORE_HOOKS[@]}"; do
        if typeset -f "$hook" >/dev/null 2>&1; then
            log-debug "Running before hook: $hook$hook$command$@"
        fi
    done
}

# Execute after hooks
_dispatcher-run-after-hooks() {
    local command="${1}"
    local exit_code="${2}"
    shift 2

    for hook in "${_DISPATCHER_AFTER_HOOKS[@]}"; do
        if typeset -f "$hook" >/dev/null 2>&1; then
            log-debug "Running after hook: $hook$hook$command$exit_code$@"
        fi
    done
}

# ------------------------------
# Global Flag Parsing
# ------------------------------

# Parse global flags before subcommand
# Sets DISPATCHER_VERBOSE, DISPATCHER_DEBUG, DISPATCHER_DRY_RUN
# Returns remaining arguments (subcommand and its args)
#
# Usage:
#   eval "$(dispatcher-parse-global-flags "$@")"
#   # Now $@ contains only subcommand and its args
#
# Recognized flags:
#   --verbose, -v  : Sets DISPATCHER_VERBOSE=true
#   --debug        : Sets DISPATCHER_DEBUG=true
#   --dry-run      : Sets DISPATCHER_DRY_RUN=true
#   --quiet, -q    : Sets DISPATCHER_VERBOSE=false
#
dispatcher-parse-global-flags() {
    local -a args=()
    local verbose="${DISPATCHER_VERBOSE}"
    local debug="${DISPATCHER_DEBUG}"
    local dry_run="${DISPATCHER_DRY_RUN}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                verbose=true
                shift
                ;;
            --quiet|-q)
                verbose=false
                shift
                ;;
            --debug)
                debug=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # Output variable assignments
    echo "DISPATCHER_VERBOSE=$verbose"
    echo "DISPATCHER_DEBUG=$debug"
    echo "DISPATCHER_DRY_RUN=$dry_run"
    echo "set -- ${args[@]}"

    # Export for subcommands
    export DISPATCHER_VERBOSE="$verbose"
    export DISPATCHER_DEBUG="$debug"
    export DISPATCHER_DRY_RUN="$dry_run"
}

# Check if verbose mode is enabled
# Usage: dispatcher-is-verbose && echo "Verbose mode"
dispatcher-is-verbose() {
    [[ "$DISPATCHER_VERBOSE" == "true" ]]
}

# Check if debug mode is enabled
# Usage: dispatcher-is-debug && echo "Debug mode"
dispatcher-is-debug() {
    [[ "$DISPATCHER_DEBUG" == "true" ]]
}

# Check if dry-run mode is enabled
# Usage: dispatcher-is-dry-run && echo "Dry run mode"
dispatcher-is-dry-run() {
    [[ "$DISPATCHER_DRY_RUN" == "true" ]]
}

# ------------------------------
# Command Execution
# ------------------------------

# Execute a subcommand
# Finds and executes the subcommand executable with given arguments
#
# Usage: dispatcher-execute-command "list" arg1 arg2
#
dispatcher-execute-command() {
    local command="${1}"
    shift

    # Resolve aliases
    command=$(dispatcher-resolve-alias "$command")

    # Find command path
    local cmd_path
    cmd_path=$(dispatcher-find-command "$command")

    if [[ -z "$cmd_path" ]]; then
        log-error "Unknown command: $command"
        echo dispatcher-list-commands
        return 1
    fi

    # Emit event if available
    if [[ "$DISPATCHER_EVENTS_AVAILABLE" == "true" ]]; then
        events-emit "dispatcher.command.start$DISPATCHER_NAME$command"
    fi

    # Run before hooks
    _dispatcher-run-before-hooks "$command$@"

    # Execute command
    log-debug "Executing command: $cmd_path $@"

    if dispatcher-is-dry-run; then
        log-info "[DRY RUN] Would execute: $cmd_path $@"
        local exit_code=0
    else
        exec "$cmd_path$@"
        local exit_code=$?
    fi

    # Run after hooks
    _dispatcher-run-after-hooks "$command$exit_code$@"

    # Emit event if available
    if [[ "$DISPATCHER_EVENTS_AVAILABLE" == "true" ]]; then
        events-emit "dispatcher.command.complete$DISPATCHER_NAME$command$exit_code"
    fi

    return $exit_code
}

# Main execution handler
# Handles special commands (help, version, commands) and routes to subcommands
#
# Usage: dispatcher-execute "$@"
#
dispatcher-execute() {
    local command="${1:-}"

    # Check initialization
    if ! dispatcher-check-init; then
        return 1
    fi

    # Handle no command
    if [[ -z "$command" ]]; then
        dispatcher-show-help
        return 0
    fi

    # Handle special commands
    case "$command" in
        help|--help|-h)
            shift
            if [[ -n "$1" ]] && dispatcher-command-exists "$1"; then
                # Show help for specific command
                dispatcher-execute-command "$1" --help
            else
                dispatcher-show-help
            fi
            return 0
            ;;
        version|--version|-v)
            dispatcher-show-version
            return 0
            ;;
        commands|list-commands)
            dispatcher-list-commands-detailed
            return 0
            ;;
        completion|--completion)
            shift
            dispatcher-generate-completion "$@"
            return 0
            ;;
    esac

    # Execute subcommand
    dispatcher-execute-command "$@"
}

# ------------------------------
# Output Functions
# ------------------------------

# List all available commands (simple)
# Usage: dispatcher-list-commands
dispatcher-list-commands() {
    local commands=($(dispatcher-get-commands))

    if [[ ${#commands[@]} -eq 0 ]]; then
        echo "No subcommands available for ${DISPATCHER_NAME}"
        return 0
    fi

    echo "Available commands:"
    for cmd in "${commands[@]}"; do
        echo "  $cmd"
    done
}

# List all available commands with descriptions
# Usage: dispatcher-list-commands-detailed
dispatcher-list-commands-detailed() {
    local commands=($(dispatcher-get-commands))

    if [[ ${#commands[@]} -eq 0 ]]; then
        echo "No subcommands available for ${DISPATCHER_NAME}"
        return 0
    fi

    echo "Available commands:"
    for cmd in "${commands[@]}"; do
        local desc=$(dispatcher-get-command-description "$cmd")
        if [[ -n "$desc" ]]; then
            printf "  %-20s %s\n$cmd$desc"
        else
            echo "  $cmd"
        fi
    done
}

# Show help message
# Can be overridden by defining dispatcher-custom-help in main script
#
# Usage: dispatcher-show-help
#
dispatcher-show-help() {
    # Check if custom help is defined
    if typeset -f dispatcher-custom-help >/dev/null 2>&1; then
        dispatcher-custom-help
        return 0
    fi

    # Default help
    local desc="${DISPATCHER_DESCRIPTION}"
    [[ -n "$desc" ]] && echo "$desc" && echo echo "Usage: ${DISPATCHER_NAME} <command> [options]"
    echo dispatcher-list-commands-detailed
    echo echo "Global options:"
    echo "  -v, --verbose           Enable verbose output"
    echo "  -q, --quiet             Disable verbose output"
    echo "  --debug                 Enable debug output"
    echo "  --dry-run               Show what would be done without doing it"
    echo echo "Special commands:"
    echo "  help, --help, -h        Show this help message"
    echo "  help <command>          Show help for specific command"
    echo "  version, --version      Show version information"
    echo "  commands                List all available commands"
    echo echo "Run '${DISPATCHER_NAME} <command> --help' for command-specific help"
}

# Show version information
# Can be overridden by defining dispatcher-custom-version in main script
#
# Usage: dispatcher-show-version
#
dispatcher-show-version() {
    # Check if custom version is defined
    if typeset -f dispatcher-custom-version >/dev/null 2>&1; then
        dispatcher-custom-version
        return 0
    fi

    # Default version
    echo "${DISPATCHER_NAME} version ${DISPATCHER_VERSION_STRING}"
}

# ------------------------------
# Error Handling
# ------------------------------

# Print error message to stderr
# Usage: dispatcher-error "Something went wrong"
dispatcher-error() {
    log-error "$*"
}

# Print warning message to stderr
# Usage: dispatcher-warning "This is a warning"
dispatcher-warning() {
    log-warn "$*"
}

# Validate command before execution
# Usage: dispatcher-validate-command "list" || return 1
dispatcher-validate-command() {
    local command="${1}"

    if [[ -z "$command" ]]; then
        log-error "Command name required"
        return 1
    fi

    if ! dispatcher-command-exists "$command"; then
        log-error "Unknown command: $command"
        return 1
    fi

    return 0
}

# ------------------------------
# Bash Completion Support
# ------------------------------

# Generate bash completion script
# Usage: dispatcher-generate-completion > /etc/bash_completion.d/mycommand
dispatcher-generate-completion() {
    local shell="${1:-bash}"

    case "$shell" in
        bash)
            _dispatcher-generate-bash-completion
            ;;
        zsh)
            _dispatcher-generate-zsh-completion
            ;;
        *)
            log-error "Unsupported shell: $shell (supported: bash, zsh)"
            return 1
            ;;
    esac
}

# Generate bash completion
_dispatcher-generate-bash-completion() {
    local commands=($(dispatcher-get-commands))
    local cmd_list=$(echo "${commands[@]}")

    cat << EOF
# Bash completion for ${DISPATCHER_NAME}
_${DISPATCHER_NAME}_completion() {
    local cur="\${COMP_WORDS[COMP_CWORD]}"
    local prev="\${COMP_WORDS[COMP_CWORD-1]}"

    # Complete global flags
    local global_flags="--verbose -v --quiet -q --debug --dry-run --help -h --version"

    if [[ \$COMP_CWORD -eq 1 ]]; then
        # Complete commands and special commands
        COMPREPLY=( \$(compgen -W "help version commands $cmd_list \$global_flags" -- "\$cur") )
    else
        # Let subcommand handle its own completion
        # (Could be extended to source subcommand completion)
        COMPREPLY=()
    fi
}

complete -F _${DISPATCHER_NAME}_completion ${DISPATCHER_NAME}
EOF
}

# Generate zsh completion
_dispatcher-generate-zsh-completion() {
    local commands=($(dispatcher-get-commands))

    cat << EOF
#compdef ${DISPATCHER_NAME}

_${DISPATCHER_NAME}() {
    local -a commands
    commands=(
EOF

    for cmd in "${commands[@]}"; do
        local desc=$(dispatcher-get-command-description "$cmd")
        if [[ -n "$desc" ]]; then
            echo "        '$cmd:$desc'"
        else
            echo "        '$cmd'"
        fi
    done

    cat << EOF
    )

    _arguments -C \\
        '(-v --verbose)'{-v,--verbose}'[Enable verbose output]' \\
        '(-q --quiet)'{-q,--quiet}'[Disable verbose output]' \\
        '--debug[Enable debug output]' \\
        '--dry-run[Show what would be done]' \\
        '(-h --help)'{-h,--help}'[Show help]' \\
        '--version[Show version]' \\
        '1:command:->command' \\
        '*::arg:->args'

    case \$state in
        command)
            _describe '${DISPATCHER_NAME} command' commands
            ;;
    esac
}

_${DISPATCHER_NAME}
EOF
}

# ------------------------------
# Self-Test
# ------------------------------

# Test dispatcher functions
# Usage: dispatcher-self-test
dispatcher-self-test() {
    echo "=== _dispatcher v${DISPATCHER_VERSION} Self-Test ==="
    echo local tests_passed=0
    local tests_failed=0

    # Test 1: Initialization
    echo -n "Test 1: Initialization... "
    dispatcher-init "testcmd/tmp1.0.0Test command dispatcher"
    if [[ "$DISPATCHER_NAME" == "testcmd" ]] && [[ "$DISPATCHER_VERSION_STRING" == "1.0.0" ]]; then
        echo "PASS"
        ((tests_passed++))
    else
        echo "FAIL"
        ((tests_failed++))
    fi

    # Test 2: Check initialization
    echo -n "Test 2: Check initialization... "
    if dispatcher-check-init; then
        echo "PASS"
        ((tests_passed++))
    else
        echo "FAIL"
        ((tests_failed++))
    fi

    # Test 3: Command discovery
    echo -n "Test 3: Command discovery... "
    local count=$(dispatcher-count-commands)
    if [[ "$count" =~ ^[0-9]+$ ]]; then
        echo "PASS (found $count commands)"
        ((tests_passed++))
    else
        echo "FAIL"
        ((tests_failed++))
    fi

    # Test 4: Alias registration
    echo -n "Test 4: Alias registration... "
    dispatcher-register-alias "lslist"
    local resolved=$(dispatcher-resolve-alias "ls")
    if [[ "$resolved" == "list" ]]; then
        echo "PASS"
        ((tests_passed++))
    else
        echo "FAIL (got: $resolved)"
        ((tests_failed++))
    fi

    # Test 5: Global flag parsing
    echo -n "Test 5: Global flag parsing... "
    eval "$(dispatcher-parse-global-flags --verbose --debug test command)"
    if [[ "$DISPATCHER_VERBOSE" == "true" ]] && [[ "$DISPATCHER_DEBUG" == "true" ]]; then
        echo "PASS"
        ((tests_passed++))
    else
        echo "FAIL"
        ((tests_failed++))
    fi

    # Test 6: Hook registration
    echo -n "Test 6: Hook registration... "
    test_hook() { true; }
    dispatcher-before "test_hook"
    dispatcher-after "test_hook"
    if [[ ${#_DISPATCHER_BEFORE_HOOKS[@]} -eq 1 ]] && [[ ${#_DISPATCHER_AFTER_HOOKS[@]} -eq 1 ]]; then
        echo "PASS"
        ((tests_passed++))
    else
        echo "FAIL"
        ((tests_failed++))
    fi

    echo echo "=== Self-Test Summary ==="
    echo "Passed: $tests_passed"
    echo "Failed: $tests_failed"
    echo if (( tests_failed == 0 )); then
        echo "All tests passed!"
        return 0
    else
        echo "Some tests failed."
        return 1
    fi
}

# ------------------------------
# Version Info
# ------------------------------

# Print version information
# Usage: dispatcher-version
dispatcher-version() {
    echo "_dispatcher v${DISPATCHER_VERSION}"
}

# ------------------------------
# Auto-run self-test if executed directly
# ------------------------------

if [[ "${ZSH_EVAL_CONTEXT}" == "toplevel" ]] || [[ "${(%):-%x}" == "${0}" ]]; then
    dispatcher-self-test
fi
