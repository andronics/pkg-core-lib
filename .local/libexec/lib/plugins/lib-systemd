#!/usr/bin/env zsh

# lib-systemd - Systemd service management and integration
# Part of the dotfiles library v2.0
# Version: 1.0.0
#
# Usage:
#   source #
# Provides:
#   - Service control (start, stop, restart, reload)
#   - Service status checking (active, enabled, failed)
#   - Unit file generation helpers
#   - Journal log access
#   - Timer management
#   - Both user and system service support
#   - Dry-run mode support
#   - Event integration
#
# Dependencies:
#   Required:
#     - _common v2.0: Core utilities
#     - systemctl command (systemd)
#   Optional (gracefully degraded):
#     - _log v2.0: Logging functions
#     - _events v2.0: Event system integration
#     - _dryrun v2.0: Dry-run mode support
#     - _process v2.0: PID management

# ------------------------------
# Source Guard
# ------------------------------

[[ -n "${SYSTEMD_LOADED:-}" ]] && return 0
declare -g SYSTEMD_LOADED=1

# ------------------------------
# Version
# ------------------------------

declare -gr SYSTEMD_VERSION="1.0.0"

# ------------------------------
# Load Dependencies
# ------------------------------

# Load _common (required) - try multiple locations
if [[ -z "${COMMON_LOADED:-}" ]]; then
    local _found=false
    for _path in \
        "$HOME/.local/libexec/lib/core/lib-common" \
        "$HOME/.local/libexec/lib/core/lib-common" \
        ; do
        if [[ -f "$_path" ]] && source "$_path" 2>/dev/null; then
            _found=true
            break
        fi
    done
    if [[ "$_found" != "true" ]]; then
        echo "[ERROR] lib-systemd requires _common v2.0 - cannot load" >&2
        return 6
    fi
    unset _found _path
fi

# Check if systemd is available
if ! common-command-exists "systemctl"; then
    echo "[ERROR] lib-systemd requires systemctl (systemd) - not found" >&2
    return 7
fi

# Load _log (optional with fallback)
if [[ -z "${LOG_LOADED:-}" ]]; then
    for _path in \
        "$HOME/.local/libexec/lib/core/lib-log" \
        "$HOME/.local/libexec/lib/core/lib-log" \
        ; do
        if [[ -f "$_path" ]] && source "$_path" 2>/dev/null; then
            break
        fi
    done
    unset _path

    # Fallback logging if _log not loaded
    if [[ -z "${LOG_LOADED:-}" ]]; then
        log-info() { echo "[INFO] $*"; }
        log-error() { echo "[ERROR] $*" >&2; }
        log-warning() { echo "[WARNING] $*" >&2; }
        log-debug() { [[ "${SYSTEMD_DEBUG:-false}" == "true" ]] && echo "[DEBUG] $*" >&2 || true; }
        log-success() { echo "[SUCCESS] $*"; }
    fi
fi

# Load _events (optional)
if [[ -z "${EVENTS_LOADED:-}" ]]; then
    for _path in \
        "$HOME/.local/libexec/lib/core/lib-events" \
        "$HOME/.local/libexec/lib/core/lib-events" \
        ; do
        if [[ -f "$_path" ]] && source "$_path" 2>/dev/null; then
            break
        fi
    done
    unset _path
fi

# Load _process (optional)
if [[ -z "${PROCESS_LOADED:-}" ]]; then
    for _path in \
        "$HOME/.local/libexec/lib/plugins/lib-process" \
        "$HOME/.local/libexec/lib/plugins/lib-process" \
        ; do
        if [[ -f "$_path" ]] && source "$_path" 2>/dev/null; then
            break
        fi
    done
    unset _path
fi

# ------------------------------
# Configuration Variables
# ------------------------------

# Enable debug logging
declare -g SYSTEMD_DEBUG="${SYSTEMD_DEBUG:-false}"

# Dry-run mode (preview actions without executing)
declare -g SYSTEMD_DRY_RUN="${SYSTEMD_DRY_RUN:-false}"

# Enable event emission
declare -g SYSTEMD_EMIT_EVENTS="${SYSTEMD_EMIT_EVENTS:-true}"

# Default scope (--user or --system)
declare -g SYSTEMD_DEFAULT_SCOPE="${SYSTEMD_DEFAULT_SCOPE:---user}"

# ------------------------------
# Service Status Functions
# ------------------------------

# Check if service is active
# Usage: systemd-is-active "myservice" [--user|--system]
# Exit codes:
#   0 - Service is active
#   1 - Service is not active
systemd-is-active() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope is-active "$unit" >/dev/null 2>&1
}

# Check if service is enabled
# Usage: systemd-is-enabled "myservice" [--user|--system]
# Exit codes:
#   0 - Service is enabled
#   1 - Service is not enabled
systemd-is-enabled() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope is-enabled "$unit" >/dev/null 2>&1
}

# Check if service is failed
# Usage: systemd-is-failed "myservice" [--user|--system]
# Exit codes:
#   0 - Service is failed
#   1 - Service is not failed
systemd-is-failed() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope is-failed "$unit" >/dev/null 2>&1
}

# Get service status (full status output)
# Usage: status=$(systemd-get-status "myservice" [--user|--system])
systemd-get-status() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope status "$unit" 2>/dev/null
}

# Get service active state (active, inactive, failed, etc.)
# Usage: state=$(systemd-get-state "myservice" [--user|--system])
systemd-get-state() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope is-active "$unit" 2>/dev/null || echo "inactive"
}

# Check if service exists (unit file is present)
# Usage: systemd-exists "myservice" [--user|--system]
systemd-exists() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope list-unit-files "$unit" --no-pager 2>/dev/null | grep -q "$unit"
}

# ------------------------------
# Service Control Functions
# ------------------------------

# Start service
# Usage: systemd-start "myservice" [--user|--system]
# Exit codes:
#   0 - Success
#   1 - Service not found
#   2 - Failed to start
systemd-start() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-start: unit name required"
        return 1
    fi

    log-debug "systemd-start: starting $unit ($scope)"

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would start: systemctl $scope start $unit"
        return 0
    fi

    # Start service
    if systemctl $scope start "$unit" 2>/dev/null; then
        log-debug "systemd-start: $unit started successfully"
        systemd--emit-event "service.started$unit$scope"
        return 0
    else
        local exit_code=$?
        log-error "systemd-start: failed to start $unit (exit=$exit_code)"
        systemd--emit-event "service.start-failed$unit$scope$exit_code"
        return 2
    fi
}

# Stop service
# Usage: systemd-stop "myservice" [--user|--system]
# Exit codes:
#   0 - Success
#   1 - Service not found
#   2 - Failed to stop
systemd-stop() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-stop: unit name required"
        return 1
    fi

    log-debug "systemd-stop: stopping $unit ($scope)"

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would stop: systemctl $scope stop $unit"
        return 0
    fi

    # Stop service
    if systemctl $scope stop "$unit" 2>/dev/null; then
        log-debug "systemd-stop: $unit stopped successfully"
        systemd--emit-event "service.stopped$unit$scope"
        return 0
    else
        local exit_code=$?
        log-error "systemd-stop: failed to stop $unit (exit=$exit_code)"
        systemd--emit-event "service.stop-failed$unit$scope$exit_code"
        return 2
    fi
}

# Restart service
# Usage: systemd-restart "myservice" [--user|--system]
# Exit codes:
#   0 - Success
#   1 - Service not found
#   2 - Failed to restart
systemd-restart() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-restart: unit name required"
        return 1
    fi

    log-debug "systemd-restart: restarting $unit ($scope)"

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would restart: systemctl $scope restart $unit"
        return 0
    fi

    # Restart service
    if systemctl $scope restart "$unit" 2>/dev/null; then
        log-debug "systemd-restart: $unit restarted successfully"
        systemd--emit-event "service.restarted$unit$scope"
        return 0
    else
        local exit_code=$?
        log-error "systemd-restart: failed to restart $unit (exit=$exit_code)"
        systemd--emit-event "service.restart-failed$unit$scope$exit_code"
        return 2
    fi
}

# Reload service configuration
# Usage: systemd-reload "myservice" [--user|--system]
# Exit codes:
#   0 - Success
#   1 - Service not found
#   2 - Failed to reload
systemd-reload() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-reload: unit name required"
        return 1
    fi

    log-debug "systemd-reload: reloading $unit ($scope)"

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would reload: systemctl $scope reload $unit"
        return 0
    fi

    # Reload service
    if systemctl $scope reload "$unit" 2>/dev/null; then
        log-debug "systemd-reload: $unit reloaded successfully"
        systemd--emit-event "service.reloaded$unit$scope"
        return 0
    else
        local exit_code=$?
        log-error "systemd-reload: failed to reload $unit (exit=$exit_code)"
        return 2
    fi
}

# Try to reload, restart if reload not supported
# Usage: systemd-reload-or-restart "myservice" [--user|--system]
systemd-reload-or-restart() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-reload-or-restart: unit name required"
        return 1
    fi

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would reload-or-restart: systemctl $scope reload-or-restart $unit"
        return 0
    fi

    systemctl $scope reload-or-restart "$unit" 2>/dev/null
}

# ------------------------------
# Service Enable/Disable Functions
# ------------------------------

# Enable service (start on boot/login)
# Usage: systemd-enable "myservice" [--user|--system]
systemd-enable() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-enable: unit name required"
        return 1
    fi

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would enable: systemctl $scope enable $unit"
        return 0
    fi

    if systemctl $scope enable "$unit" 2>/dev/null; then
        log-debug "systemd-enable: $unit enabled"
        systemd--emit-event "service.enabled$unit$scope"
        return 0
    else
        log-error "systemd-enable: failed to enable $unit"
        return 1
    fi
}

# Disable service (don't start on boot/login)
# Usage: systemd-disable "myservice" [--user|--system]
systemd-disable() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if [[ -z "$unit" ]]; then
        log-error "systemd-disable: unit name required"
        return 1
    fi

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would disable: systemctl $scope disable $unit"
        return 0
    fi

    if systemctl $scope disable "$unit" 2>/dev/null; then
        log-debug "systemd-disable: $unit disabled"
        systemd--emit-event "service.disabled$unit$scope"
        return 0
    else
        log-error "systemd-disable: failed to disable $unit"
        return 1
    fi
}

# Enable and start service
# Usage: systemd-enable-start "myservice" [--user|--system]
systemd-enable-start() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemd-enable "$unit$scope" && systemd-start "$unit$scope"
}

# Stop and disable service
# Usage: systemd-disable-stop "myservice" [--user|--system]
systemd-disable-stop() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemd-stop "$unit$scope" && systemd-disable "$unit$scope"
}

# ------------------------------
# Daemon Control Functions
# ------------------------------

# Reload systemd daemon (after unit file changes)
# Usage: systemd-daemon-reload [--user|--system]
systemd-daemon-reload() {
    local scope="${1:-$SYSTEMD_DEFAULT_SCOPE}"

    # Dry-run mode
    if [[ "${SYSTEMD_DRY_RUN}" == "true" ]]; then
        log-info "[DRY-RUN] Would reload daemon: systemctl $scope daemon-reload"
        return 0
    fi

    if systemctl $scope daemon-reload 2>/dev/null; then
        log-debug "systemd-daemon-reload: daemon reloaded ($scope)"
        systemd--emit-event "daemon.reloaded$scope"
        return 0
    else
        log-error "systemd-daemon-reload: failed to reload daemon"
        return 1
    fi
}

# ------------------------------
# Unit File Generation Functions
# ------------------------------

# Generate a simple service unit file
# Usage: systemd-generate-service "myservice/path/to/execDescription" [type] [restart] [restart_sec]
# Output: Service unit file content
systemd-generate-service() {
    local service_name="$1"
    local exec_start="$2"
    local description="${3:-$service_name service}"
    local type="${4:-simple}"
    local restart="${5:-on-failure}"
    local restart_sec="${6:-5s}"

    cat <<EOF
[Unit]
Description=$description
After=network.target

[Service]
Type=$type
ExecStart=$exec_start
Restart=$restart
RestartSec=$restart_sec

[Install]
WantedBy=default.target
EOF
}

# Generate a template service unit file (myservice@.service)
# Usage: systemd-generate-template "myservice/path/to/exec %iDescription"
# Output: Template service unit file content
systemd-generate-template() {
    local service_name="$1"
    local exec_start="$2"
    local description="${3:-$service_name@%i service}"
    local type="${4:-simple}"
    local restart="${5:-on-failure}"

    cat <<EOF
[Unit]
Description=$description
After=network.target

[Service]
Type=$type
ExecStart=$exec_start
Restart=$restart
RestartSec=5s

[Install]
WantedBy=default.target
EOF
}

# Generate a timer unit file
# Usage: systemd-generate-timer "mytimerdailyRun daily" [service_name]
# Output: Timer unit file content
systemd-generate-timer() {
    local timer_name="$1"
    local on_calendar="$2"
    local description="${3:-$timer_name timer}"
    local service_name="${4:-${timer_name%.timer}}"

    cat <<EOF
[Unit]
Description=$description

[Timer]
OnCalendar=$on_calendar
Persistent=true

[Install]
WantedBy=timers.target
EOF
}

# ------------------------------
# Journal Functions
# ------------------------------

# View service logs
# Usage: systemd-logs "myservice" [lines] [--user|--system]
systemd-logs() {
    local unit="$1"
    local lines="${2:-50}"
    local scope="${3:-$SYSTEMD_DEFAULT_SCOPE}"

    if ! common-command-exists "journalctl"; then
        log-error "systemd-logs: journalctl command not found"
        return 1
    fi

    journalctl $scope -u "$unit" -n "$lines" --no-pager
}

# Follow service logs
# Usage: systemd-logs-follow "myservice" [--user|--system]
systemd-logs-follow() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    if ! common-command-exists "journalctl"; then
        log-error "systemd-logs-follow: journalctl command not found"
        return 1
    fi

    journalctl $scope -u "$unit" -f
}

# View logs since timestamp
# Usage: systemd-logs-since "myservice2025-01-01 00:00:00" [--user|--system]
systemd-logs-since() {
    local unit="$1"
    local since="$2"
    local scope="${3:-$SYSTEMD_DEFAULT_SCOPE}"

    if ! common-command-exists "journalctl"; then
        log-error "systemd-logs-since: journalctl command not found"
        return 1
    fi

    journalctl $scope -u "$unit" --since "$since" --no-pager
}

# View logs for priority level
# Usage: systemd-logs-priority "myserviceerr" [--user|--system]
# Priority: emerg, alert, crit, err, warning, notice, info, debug
systemd-logs-priority() {
    local unit="$1"
    local priority="${2:-err}"
    local scope="${3:-$SYSTEMD_DEFAULT_SCOPE}"

    if ! common-command-exists "journalctl"; then
        log-error "systemd-logs-priority: journalctl command not found"
        return 1
    fi

    journalctl $scope -u "$unit" -p "$priority" --no-pager
}

# ------------------------------
# Listing Functions
# ------------------------------

# List all services
# Usage: systemd-list-services [--user|--system]
systemd-list-services() {
    local scope="${1:-$SYSTEMD_DEFAULT_SCOPE}"
    systemctl $scope list-units --type=service --all --no-pager
}

# List enabled services
# Usage: systemd-list-enabled [--user|--system]
systemd-list-enabled() {
    local scope="${1:-$SYSTEMD_DEFAULT_SCOPE}"
    systemctl $scope list-unit-files --type=service --state=enabled --no-pager
}

# List failed services
# Usage: systemd-list-failed [--user|--system]
systemd-list-failed() {
    local scope="${1:-$SYSTEMD_DEFAULT_SCOPE}"
    systemctl $scope list-units --type=service --state=failed --no-pager
}

# List running services
# Usage: systemd-list-running [--user|--system]
systemd-list-running() {
    local scope="${1:-$SYSTEMD_DEFAULT_SCOPE}"
    systemctl $scope list-units --type=service --state=running --no-pager
}

# ------------------------------
# Property Functions
# ------------------------------

# Get service property
# Usage: pid=$(systemd-get-property "myserviceMainPID" [--user|--system])
systemd-get-property() {
    local unit="$1"
    local property="$2"
    local scope="${3:-$SYSTEMD_DEFAULT_SCOPE}"

    systemctl $scope show "$unit" --property="$property" --value 2>/dev/null
}

# Get service PID
# Usage: pid=$(systemd-get-pid "myservice" [--user|--system])
systemd-get-pid() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemd-get-property "$unitMainPID$scope"
}

# Get service memory usage
# Usage: mem=$(systemd-get-memory "myservice" [--user|--system])
systemd-get-memory() {
    local unit="$1"
    local scope="${2:-$SYSTEMD_DEFAULT_SCOPE}"

    systemd-get-property "$unitMemoryCurrent$scope"
}

# ------------------------------
# Utility Functions
# ------------------------------

# Check if systemd is available
# Usage: systemd-available || echo "systemd not available"
systemd-available() {
    common-command-exists "systemctl"
}

# Get systemd version
# Usage: version=$(systemd-version)
systemd-version() {
    systemctl --version | head -1 | awk '{print $2}'
}

# Wait for service to be active
# Usage: systemd-wait-active "myservice" [timeout_seconds] [--user|--system]
systemd-wait-active() {
    local unit="$1"
    local timeout="${2:-30}"
    local scope="${3:-$SYSTEMD_DEFAULT_SCOPE}"

    local elapsed=0
    local interval=1

    while [[ $elapsed -lt $timeout ]]; do
        if systemd-is-active "$unit$scope"; then
            log-debug "systemd-wait-active: $unit is active (waited ${elapsed}s)"
            return 0
        fi

        sleep $interval
        elapsed=$((elapsed + interval))
    done

    log-error "systemd-wait-active: timeout waiting for $unit to be active"
    return 1
}

# ------------------------------
# Internal Helper Functions
# ------------------------------

# Emit event (if _events is available)
systemd--emit-event() {
    if [[ "${SYSTEMD_EMIT_EVENTS}" != "true" ]] || [[ -z "${EVENTS_LOADED:-}" ]]; then
        return 0
    fi

    events-emit "$@"
}

# ------------------------------
# Self-Test Function
# ------------------------------

systemd-self-test() {
    echo "=== _systemd v${SYSTEMD_VERSION} self-test ==="
    echo local tests_passed=0
    local tests_failed=0

    # Test 1: Systemd availability
    echo -n "Test 1: Systemd availability... "
    if systemd-available; then
        echo "PASS (version $(systemd-version))"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    # Test 2: Dry-run mode
    echo -n "Test 2: Dry-run mode... "
    SYSTEMD_DRY_RUN=true
    if systemd-start "test-service--user" 2>&1 | grep -q "DRY-RUN"; then
        echo "PASS"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi
    SYSTEMD_DRY_RUN=false

    # Test 3: Unit file generation (service)
    echo -n "Test 3: Service unit generation... "
    local service_content=$(systemd-generate-service "test/usr/bin/testTest service")
    if echo "$service_content" | grep -q "ExecStart=/usr/bin/test"; then
        echo "PASS"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    # Test 4: Unit file generation (timer)
    echo -n "Test 4: Timer unit generation... "
    local timer_content=$(systemd-generate-timer "testdailyTest timer")
    if echo "$timer_content" | grep -q "OnCalendar=daily"; then
        echo "PASS"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    # Test 5: Check common system service (if available)
    echo -n "Test 5: Check system service status... "
    if systemd-exists "dbus.service--system" 2>/dev/null; then
        echo "PASS (dbus.service exists)"
        tests_passed=$((tests_passed + 1))
    else
        echo "SKIP (dbus.service not available)"
    fi

    # Test 6: Service existence check
    echo -n "Test 6: Service existence check... "
    if ! systemd-exists "nonexistent-service-12345--user"; then
        echo "PASS"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    # Test 7: Get property (systemd version)
    echo -n "Test 7: Get systemd version... "
    local version=$(systemd-version)
    if [[ -n "$version" ]] && [[ "$version" =~ ^[0-9]+$ ]]; then
        echo "PASS (version=$version)"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    # Test 8: Template generation
    echo -n "Test 8: Template unit generation... "
    local template_content=$(systemd-generate-template "test@/usr/bin/test %i")
    if echo "$template_content" | grep -q "%i"; then
        echo "PASS"
        tests_passed=$((tests_passed + 1))
    else
        echo "FAIL"
        tests_failed=$((tests_failed + 1))
    fi

    echo echo "=== Results: $tests_passed passed, $tests_failed failed ==="

    if [[ $tests_failed -eq 0 ]]; then
        echo "SUCCESS: All tests passed"
        return 0
    else
        echo "FAILURE: Some tests failed"
        return 1
    fi
}
